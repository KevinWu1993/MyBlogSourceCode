{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/about/github.png","path":"about/github.png","modified":1,"renderable":0},{"_id":"source/about/mail.png","path":"about/mail.png","modified":1,"renderable":0},{"_id":"source/about/weibo.png","path":"about/weibo.png","modified":1,"renderable":0},{"_id":"themes/Hacker/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/images/icon-bookmark-fill.svg","path":"images/icon-bookmark-fill.svg","modified":1,"renderable":1},{"_id":"themes/Hacker/source/images/icon-bookmark.svg","path":"images/icon-bookmark.svg","modified":1,"renderable":1},{"_id":"themes/Hacker/source/images/icon-bubble-fill.svg","path":"images/icon-bubble-fill.svg","modified":1,"renderable":1},{"_id":"themes/Hacker/source/images/icon-bubble.svg","path":"images/icon-bubble.svg","modified":1,"renderable":1},{"_id":"themes/Hacker/source/images/icon-heart-fill.svg","path":"images/icon-heart-fill.svg","modified":1,"renderable":1},{"_id":"themes/Hacker/source/images/icon-heart.svg","path":"images/icon-heart.svg","modified":1,"renderable":1},{"_id":"themes/Hacker/source/images/icon-tags.svg","path":"images/icon-tags.svg","modified":1,"renderable":1},{"_id":"themes/Hacker/source/js/script.js","path":"js/script.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/Hacker/.gitignore","hash":"803c06a7086b5817c03d2e8672da27bc56ba2bce","modified":1458275046000},{"_id":"themes/Hacker/README.md","hash":"73e14052e3cd82917c792f9346de54c97b470108","modified":1458275046000},{"_id":"themes/Hacker/_config.yml","hash":"651cc2f972a0c6022fd0b1659e250412901dd725","modified":1458481253000},{"_id":"themes/Hacker/_config.yml~","hash":"021128872b1f9e22303d109908a53c0de386c16e","modified":1458481122000},{"_id":"source/about/github.png","hash":"90620a403a15fb0f96a58c5095ec804661b21986","modified":1458285003000},{"_id":"source/about/index.md","hash":"e984fe3b0f838ea1673aaa9561cdb45c908ab74e","modified":1458481307000},{"_id":"source/about/mail.png","hash":"a59a8932f387ad9c0fee773a847dd858f47ac938","modified":1458284998000},{"_id":"source/about/weibo.png","hash":"154cd02b8288547b7ff3eaf7e97256c66d97d924","modified":1458285007000},{"_id":"source/categories/index.md","hash":"89899e56cf724746e070c38b2038d273ac7d0066","modified":1458480701000},{"_id":"source/link/index.md","hash":"3924b87857b7619c16fd4bb6f12048b28eef9acd","modified":1458442198000},{"_id":"source/tags/index.md","hash":"4fabeec228c2fea51a5d70cd8de8f48ce153cc12","modified":1458474830000},{"_id":"themes/Hacker/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1458275046000},{"_id":"themes/Hacker/.git/config","hash":"3881ea13a75b317ec3e3c5fd6e4ac0e0d361b81e","modified":1458275046000},{"_id":"themes/Hacker/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1458275041000},{"_id":"themes/Hacker/.git/index","hash":"a53090408afe2c6a419f721ccf624d9d5f261993","modified":1458275046000},{"_id":"themes/Hacker/.git/packed-refs","hash":"538bf5a5918a2ccc6f7a0277043e35a966b193a6","modified":1458275046000},{"_id":"themes/Hacker/languages/default.yml","hash":"4571e0216ed876cd8240ccbb92c9302688f82f5b","modified":1458275046000},{"_id":"themes/Hacker/languages/zh-CN.yml","hash":"fca215e77f03c8086a1665ff2de7b44b8d872ef4","modified":1458481239000},{"_id":"themes/Hacker/languages/zh-CN.yml~","hash":"0647c84a353a37cdbf00c0c1fdb73ff4ffa58abf","modified":1458481220000},{"_id":"themes/Hacker/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1458275046000},{"_id":"themes/Hacker/layout/categories.ejs","hash":"fd9a8013c38529c605195ee025b06c3e6093a126","modified":1458443257000},{"_id":"themes/Hacker/layout/categories.ejs~","hash":"38d3c76e0ea446b3e46e7aaf05c884cfd44f0556","modified":1458443014000},{"_id":"themes/Hacker/layout/category.ejs","hash":"13096bf9fde0cc8293335e02b18e0cfa2400b1b9","modified":1458443230000},{"_id":"themes/Hacker/layout/category.ejs~","hash":"dea673ea634c6d7495a7dcc76909dc5add3abf99","modified":1458443205000},{"_id":"themes/Hacker/layout/index.ejs","hash":"73f1310dbf32f4fa7d1599f678694c5a16a5ab2c","modified":1458377387000},{"_id":"themes/Hacker/layout/index.ejs~","hash":"c443038983f7abef8213af44990f0d137ad10fff","modified":1458377319000},{"_id":"themes/Hacker/layout/layout.ejs","hash":"55b25f93c97779bddd34df1a6cb402d7e04cc43f","modified":1458377294000},{"_id":"themes/Hacker/layout/layout.ejs~","hash":"a2785f68d6e5d3767caae3bd466f068616ee38d6","modified":1458275046000},{"_id":"themes/Hacker/layout/page.ejs","hash":"70cbc9854655773cc6ba84eecaaf330fed430465","modified":1458275046000},{"_id":"themes/Hacker/layout/post.ejs","hash":"70cbc9854655773cc6ba84eecaaf330fed430465","modified":1458275046000},{"_id":"themes/Hacker/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1458275046000},{"_id":"themes/Hacker/layout/tags.ejs","hash":"9d82de62026adfa47efde2a8a6361d54b7814485","modified":1458476326000},{"_id":"themes/Hacker/layout/tags.ejs~","hash":"b137daab081b9d1ee39270f62b02c48954dccddd","modified":1458476310000},{"_id":"themes/Hacker/.git/hooks/applypatch-msg.sample","hash":"86b9655a9ebbde13ac8dd5795eb4d5b539edab0f","modified":1458275041000},{"_id":"themes/Hacker/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1458275041000},{"_id":"themes/Hacker/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1458275041000},{"_id":"themes/Hacker/.git/hooks/pre-applypatch.sample","hash":"42fa41564917b44183a50c4d94bb03e1768ddad8","modified":1458275041000},{"_id":"themes/Hacker/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1458275041000},{"_id":"themes/Hacker/.git/hooks/pre-push.sample","hash":"b4ad74c989616b7395dc6c9fce9871bb1e86dfb5","modified":1458275041000},{"_id":"themes/Hacker/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1458275041000},{"_id":"themes/Hacker/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1458275041000},{"_id":"themes/Hacker/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1458275041000},{"_id":"themes/Hacker/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1458275041000},{"_id":"themes/Hacker/.git/logs/HEAD","hash":"151bef51c96b719215cb810453606d32e093436d","modified":1458275046000},{"_id":"themes/Hacker/layout/_partial/archive.ejs","hash":"ccbf286053bca8a429f3a0543955abaac093d409","modified":1458476158000},{"_id":"themes/Hacker/layout/_partial/archive.ejs~","hash":"cdc100f13f046bc267382455c5aa0ccf5f86cb4e","modified":1458475923000},{"_id":"themes/Hacker/layout/_partial/article.ejs","hash":"4ab5b047c1b3e91c974597bf1b6a9267cdda556c","modified":1458275046000},{"_id":"themes/Hacker/layout/_partial/categories.ejs","hash":"7cfbf032def6319d4f6fad568491054fc67d49ce","modified":1461211185000},{"_id":"themes/Hacker/layout/_partial/categories.ejs~","hash":"f63681d7a92a099af54c6316fb888f0193de511b","modified":1461211094000},{"_id":"themes/Hacker/layout/_partial/category.ejs~","hash":"008a199520c978e79916ebc1a4ca7e8e0d2df69d","modified":1458443045000},{"_id":"themes/Hacker/layout/_partial/comment.ejs","hash":"78ca11dc394eb95ba1cef472a28c02ee3e21f784","modified":1461211352000},{"_id":"themes/Hacker/layout/_partial/comment.ejs~","hash":"7b6b8c4658c01f6ed60eb305aa761dfff72bbd04","modified":1458480461000},{"_id":"themes/Hacker/layout/_partial/footer.ejs","hash":"170ecfe0c4946ffd5b1555dc34a695bc75f9278e","modified":1458276838000},{"_id":"themes/Hacker/layout/_partial/footer.ejs~","hash":"ff9991c1a2fe196146f296fc8917a605712596ce","modified":1458275046000},{"_id":"themes/Hacker/layout/_partial/googleanalytics.ejs","hash":"fa11251ace0fc61cbcffb74f32fbf5bdbb201ff2","modified":1458275046000},{"_id":"themes/Hacker/layout/_partial/head.ejs","hash":"bf684f4c2e277eb784a69fbbcc9d2d76ed9a22bf","modified":1458477450000},{"_id":"themes/Hacker/layout/_partial/head.ejs~","hash":"a80beda57c09bed263cd6562ff1d8fb19ec6c2b2","modified":1458275046000},{"_id":"themes/Hacker/layout/_partial/header.ejs","hash":"1b32e6c6fd869937bf7a24a94ff73cb736432e53","modified":1458275046000},{"_id":"themes/Hacker/layout/_partial/pagination.ejs","hash":"4ab5e3b0239e467923a0f91c771bcc9ee7889cfe","modified":1458275046000},{"_id":"themes/Hacker/layout/_partial/tags.ejs","hash":"e402524aa2b0bdaa523e88e4205a371b3908652b","modified":1458478042000},{"_id":"themes/Hacker/layout/_partial/tags.ejs~","hash":"d274a37523037c118383cc3bdecd6e5f7dee9559","modified":1458478034000},{"_id":"themes/Hacker/source/css/style.styl","hash":"9d6f923e38f4909cc42b502162959fa1bc45e235","modified":1458275046000},{"_id":"themes/Hacker/source/images/icon-bookmark-fill.svg","hash":"1740f4817c0126e259c12ddf38378026ab0bac29","modified":1458275046000},{"_id":"themes/Hacker/source/images/icon-bookmark.svg","hash":"8bccb4956ba866500152f5ef86a925055b8496ce","modified":1458275046000},{"_id":"themes/Hacker/source/images/icon-bubble-fill.svg","hash":"9e1d529fa0a70a16329a8034f99da05e9ea27883","modified":1458275046000},{"_id":"themes/Hacker/source/images/icon-bubble.svg","hash":"705b667e317db9b6b572f6f4153d81991a3a69a7","modified":1458275046000},{"_id":"themes/Hacker/source/images/icon-heart-fill.svg","hash":"82c01c807e5e7c2cd9f3f73e680b73fc4d44fabb","modified":1458275046000},{"_id":"themes/Hacker/source/images/icon-heart.svg","hash":"ec483e96c88eea013fd8ac71a34a875107397f43","modified":1458275046000},{"_id":"themes/Hacker/source/images/icon-tags.svg","hash":"5f7af686d28f0d1015ae6f16559f9b9658f17dd1","modified":1458275046000},{"_id":"themes/Hacker/source/js/script.js","hash":"cc5d13b73449fb4bcc7bec8aea56ed933a30d71e","modified":1458478361000},{"_id":"themes/Hacker/source/js/script.js~","hash":"007edaff7540f1f20ce454ddc5f54cee012fbcb7","modified":1458478338000},{"_id":"source/_posts/Android/201601/Gson学习笔记.md","hash":"b4ca5e049b2f7225776fff7073486eb2680fc330","modified":1458442343000},{"_id":"source/_posts/Android/201603/ Android四大组件之一——Activity.md","hash":"550bf314d748c664e5d7c527e9b55e37d7716773","modified":1458577518000},{"_id":"source/_posts/Android/201603/RxJava初步学习总结.md","hash":"c66160505e2f17a6b52a2c41e8dcd92c354c9259","modified":1458993996000},{"_id":"source/_posts/Java/201603/JVM简单个人总结（一）.md","hash":"7f8b978c95d1b6314225662c6b7816e4e58b6b1a","modified":1458285885000},{"_id":"source/_posts/Java/201603/Java集合类总结.md","hash":"e0b458e4e142e1104428afcd5eba6eb46d3379a3","modified":1458397963000},{"_id":"source/_posts/在线刷题/201603/二维数组中的查找——解题及多次优化思路分析.md","hash":"83753dd79d22516645508b4ea3a2bca138cb9b54","modified":1458999385000},{"_id":"source/_posts/计算机基础/201603/IP地址的分类.md","hash":"bc07130112a8efa05ea9dcf0794005abd3157dca","modified":1458993912000},{"_id":"source/_posts/计算机基础/201603/单工、半双工和全双工微总结.md","hash":"0246d3ab30fd4ccc90945b13b120d1d791379b95","modified":1458993945000},{"_id":"themes/Hacker/.git/objects/02/2eb492180b5aad1d860928d92a0b4bf8e32b72","hash":"183434afd3978fa138ee1d82ef7279d45a8a1a67","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/05/8021a493b7026bfc645c007faa942ba6c79025","hash":"be67d61bd5f12e2fb8b849aaf6587194bf1b105d","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/0a/940a6419577628bfb597a7a0ed38e0fc047665","hash":"eaee84a5400f8b385ea0ad6fd12ec4a3f53ff037","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/0d/d25d6822e3062bda872c8e3a439f4231519d69","hash":"970bd14c13677e94a7e61f4243568a73fbf8f224","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/11/d5cd2200f7e55a082229ff5b3348724feedd76","hash":"7cd1c32a3289e94d3744368a9c3688c2277af3d0","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/12/5cc4ffb5ccda9f770f8950f4be1334b05adc88","hash":"af85be2ce977af14210a2346e80970c4bdf0df14","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/1c/7b2f264adf7bb6b4cc8cabe519c3bf4dd946b7","hash":"5b4b932c4e18592692b4d90f7d9b88854a1ed2e6","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/24/4e36eaa9ae17ea1db6a0a084fcff93b7575eec","hash":"cac0427efb616f5a6e6f615c329911fba8110874","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/29/7e897437abf09e064c3b127b5a3aad50e5c76c","hash":"0328c1562aff7ce6bd93ec990fe996a1f833daae","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/2e/257fbd13acde1d5e8d51cb434734f124a0b42c","hash":"76a722bccf4ee170bc3077b9388aa502c56f77e6","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/30/5ac4417b6c44d3898e49a8d615476c63a5d7cf","hash":"9c2df4d5299cb6003faf2ec0aefea5b853bc2d74","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/32/b763e4509ee19d73119fcb32e740f3dd8e90ef","hash":"34f88ca73f5183b0080f9b2a1267123032474b8c","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/33/667411190412afc7cbb399ea305aecb4aeacf0","hash":"b526935174c20ad44259ab2ceded6b1b44425752","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/37/3a5088022d970fa04d6c696a5aa03e65e9e75f","hash":"e9fb44ccb3bfc0bb64428ab48bb66457656b0981","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/38/c6e051c7eb134b11e3b7f320e17ec961ab3145","hash":"9146103e6fff6886943cc6d81fafc353000e0171","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/3c/6a775999a133634d5d0d3b343844407f83b0fe","hash":"c56ab1547337fc78193ec5a686e9683a9df244c2","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/3e/5178d779572f1c4b3d4feb58819d253461ad5c","hash":"98509f6ca58b7f70c6207a0b338712485927e7ab","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/3f/32073f914e495cd44a2a5b46d744170ac3a092","hash":"827ae604bce44ea2bb246df2c26972fc8a2e7acd","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/47/957f34687cbed8ab24ea24e75858ddf671521c","hash":"21aa6aaf4d52d809086edf94e1084909f0bf6afe","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/48/cde32b10b043f498cb86a970909b881b8c8abe","hash":"807d576f295565d1a92054052300c41d45df981e","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/4e/0d80bb30449ea5b6fcb3fece4bd34cb45659c6","hash":"a2c41a537fe8b233f4d81b3a82dcf893578f82c9","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/51/b2aba96230f231a3f69f6a3756ef88eb14b9d6","hash":"db09c9065f5dcd46bffe44dab44a03fb4ee44a29","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/52/260e568a18f5326cc91fa9b5a31ed1690aea06","hash":"afd9233c7ea31e267d7124855f25a92996748bca","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/54/133ecbdd231c365e9b728fd20fcd0e0eff5ed2","hash":"df6f2a805fab5af82076cf445ebc53837e70a3ed","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/58/52692972097ef98ba32667b733003c9460fadf","hash":"3d74dd96f4f79119d759bdfcb4445f77099bf512","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/59/86c355e8fe7b5e4687dd80d2470201c1edd40d","hash":"764c065aa29da93533a01fef81b67c244ab48994","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/5c/34657346cc8a9a9d9917b8805411415769574e","hash":"b161b20f935ba28d4ea6ea600fb88294220da568","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/5e/5e3c898106bb66986f7224bf51eea2dc3c82a3","hash":"79d1b72452e2ba03045674d9562c9ce9edbfd5eb","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/5f/90de771b117f66b591f1816156ffb997928228","hash":"346da3fa06f429d493840bc2c4794dd2e53620c5","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/62/abc3a0ec93c4ffc96cd806d7e03b21f36bc9a2","hash":"efd2c3a6d1b9fd58fad0aab872f10ad72c7681f8","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/63/68ea943a8aa483f405252e53db48eb1451b5fd","hash":"232dc6c1023f75e6ae17303732a9158b03596d27","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/66/26a9012810697738d67f2fa91c7a218cb9c274","hash":"35d3aa16982dddaeca99e61eda60d4477f1449db","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/71/180ccae4ff0920d51b8a7c73fb95f4a5bd8d92","hash":"050b54c9af55d97da34fc842c3b1a20c3bd06a12","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/72/3ef36f4e4f32c4560383aa5987c575a30c6535","hash":"1978765a3c6dba881d019fc8ab9857e39a4fd12c","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/77/b9964328b92f378ade362c2a6598425af533c6","hash":"b9de9f1527600a2392ffd545604dc736ba7e2afd","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/78/2b2b18a926ee7bc91d5ff8029e1ed8414a1833","hash":"c277b0573d6b3abe2bc519a2dbb860d5c3662208","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/78/3ef07f13887848cb9dbddfb260cdd002afc0f1","hash":"5ad8319e7e886cfc54e8bc4eecaa3434c629f074","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/8c/f12f7d8ac37a63cbb31b76c535bfe6b3142da9","hash":"8c970488b3816bfdd39ac270acd0dd7e51c6f182","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/91/ee502b916adaeedd694d2b18e5d50c2c81af9c","hash":"8bbb8d22ca93549e642377d0af11c7d34827de0a","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/92/2c388ed934aea3f7791432fcc90fcaa6fa900a","hash":"2e01ba05cf1a72525fbb758eb8d5636947a65c6d","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/93/1db219735d5ad70419b2795207f5c53ffec257","hash":"f63157897fe9b94323563a24a85763db9caee1df","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/97/3fd9c5a659e1bacb892470343ee5266ae0f243","hash":"78fae452d350c2b2778503289a4e70909e927fd7","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/99/b6189074df9b6efc10da7706f39c47dd8e2e10","hash":"d7abac21bbc310971e61a064e1e2bc23207bda75","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/a3/a652f8ce0219d8beb027bcc6702118ae9e1795","hash":"8c39193d0270cb2ee13586dca9d216fd74e31b98","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/a6/39b265563a85524d4b8553080893f55990ca3f","hash":"1e418235f541452e36fc9edda24b0b30dee3fe4a","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/a8/eb542fbcafa06590de165ab68ba95115ffcd17","hash":"607956c6b58a869706819d9d5c22de57652e9d5b","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/ab/f7ae19b8fa0ec4ed6af0b13bbbc1ea4ff60517","hash":"1559673954df249ef9437df5fa5d4abf93824061","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/ac/e2f77219da9f9746c86569d94670214ffaf9b0","hash":"f82c93c1a827ee96cfb88bd45cef34fd9899804f","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/af/caee99c94d82bbe5946b0ca3f9bb85392c7107","hash":"45e51edf16072a7a18c4894517f4762ea9271492","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/b1/33fac80959b6eedfa10451216a1e7d28189a70","hash":"3c8159f782c853b44b73fc95909d640b8c8d4760","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/b1/870e7ba13f7a927443fc94583a004960739804","hash":"ad876aaf1ff7ba7a595624bd78056e84efed1e32","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/b4/0a3013627b6b202d756fe7680f443f65d7b1da","hash":"1350b6f0b19abd5a3518607eb05b2b2e7996baee","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/b6/66ed22cc80c7e81e042a9fdc5edb31b5fdf1f1","hash":"ea4728ec316f7534ca4b19bfa8108d3877dd0129","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/ba/f4851d428afc0ced6aac941a218248ebc07482","hash":"6c83520d88e219431f864bc38e4943e6900544fa","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/bb/767544a8c43dd54d1c26a4c4183e2dab8d805a","hash":"0c043cd3efdc1dd8add555b27cb72dea960b1957","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/c3/b9457f460074b5a181744f8bf5409312d7c5c7","hash":"72904bd7b579b5d8e12108a9012e3e63364aca5e","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/c5/38dfa9b371b2f3ff0dcabc7cc21b552a81690a","hash":"4db80f8652c885953ed251d43a5e5679d9c44f29","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/d2/60dc1ebe6fa00de9b6e3ba741512e3dd9cd39f","hash":"402b3c0d5caa0060b07c47a1c4276e6adf04002b","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/d3/bf36c346b4f85b68b1c26115e8c26b4d992f0e","hash":"988b11e64c6a2ad81264947cf53dca85ea9653f7","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/d6/47cdeff2be0b265875cec165d3f87afc2d324c","hash":"212db4862caa6892bea68104147f238c0e04259a","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/d9/036321555ee1d7d36af6e9bd1e1617e2909d2f","hash":"9c9fa71079c43446a90465898c53889ab6cbb500","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/dd/8968791877243a0bf24181a14a49791bd08393","hash":"59556c6ece54527a7175dfc3616d01da9a534fa3","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/df/1b3e846406ae1205e48ed9c8beb76718b6fec0","hash":"ad5fa4f8bd1a074042f2709087b20b6b7b515d0c","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/e8/871438776cf44a7ed11c602adaabd888a88ff3","hash":"9530e69b23d9ffeb05ea31bcf678330cf4efe77e","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/e9/467e0d1a4a938f80354671646ad9045c9110a9","hash":"a82e200544ecdd8d1e51555f667bcd1a8fa4c3bd","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/f8/f97def5772d42962f9992eddefed525b630e03","hash":"ae98ce4605e05e5156126f7c86a6968fa5937d8d","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/fa/9e604bc594881a399d72e969601498f2a9ba5a","hash":"92a93d5bb6f6def60292aa1d3089d19df0da0360","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/fd/29ef7db05705f65e57614a9b666f00dca6d530","hash":"73e6177c0585831e07791862f296eb642a5b1da3","modified":1458275046000},{"_id":"themes/Hacker/.git/objects/fe/ad85a3122aaf3fd0c80087c2425db527bd7167","hash":"c0d8d1af7ef03edb8ce56e3e5958603d3cab709b","modified":1458275046000},{"_id":"themes/Hacker/.git/refs/heads/master","hash":"841a6650a4726ad0c1c422ff807f289580601306","modified":1458275046000},{"_id":"themes/Hacker/layout/_partial/post/category.ejs","hash":"7625a44bf69eae40304e99aa8989d08604236edd","modified":1458275046000},{"_id":"themes/Hacker/layout/_partial/post/gallery.ejs","hash":"de577a884255f35fc14eecf3ff9a14a7d9c786be","modified":1458275046000},{"_id":"themes/Hacker/layout/_partial/post/tag.ejs","hash":"c8e8da6388c67a0d7317e49560534ce08cc55c0b","modified":1458275046000},{"_id":"themes/Hacker/layout/_partial/post/title.ejs","hash":"b3422ead73e9df2a3b6161862227e7894c2d52f0","modified":1458275046000},{"_id":"themes/Hacker/source/css/_base/layout.css","hash":"f89598a317daf5d3b345d9f9a31276fe49d99b08","modified":1458478237000},{"_id":"themes/Hacker/source/css/_base/layout.css~","hash":"75b0b754a2a8ad5cd9a78927e3a6a688c197f052","modified":1458478212000},{"_id":"themes/Hacker/source/css/_base/normalize.css","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1458393309000},{"_id":"themes/Hacker/source/css/_base/normalize.css~","hash":"cb3c896eff9bd2c56473c31dfc11d78bb3a6a8aa","modified":1458393295000},{"_id":"themes/Hacker/source/css/_base/responsive.css","hash":"9a0be8d93d0a93c24eddc0cceb6c4635a751d933","modified":1458275046000},{"_id":"themes/Hacker/source/css/_base/syntax.styl","hash":"6b4450dad6fce0392913ae93d7060da6ddb24a66","modified":1458484109000},{"_id":"themes/Hacker/source/css/_base/syntax.styl~","hash":"dc72fea2e18817121055cf9997f3829c27918cce","modified":1458483923000},{"_id":"themes/Hacker/source/css/_partial/archive.css","hash":"4d1e0677bfdde9c6d61ba0f962f4c0dbfce5eebc","modified":1458391475000},{"_id":"themes/Hacker/source/css/_partial/archive.css~","hash":"18ec616daa506ea0456911f1635b44703544f40f","modified":1458391458000},{"_id":"themes/Hacker/source/css/_partial/article.css","hash":"f623314342e46cc7f72da0eab0fc2f9af02a4dd7","modified":1461211293000},{"_id":"themes/Hacker/source/css/_partial/article.css~","hash":"b470dc18d73e7ca6302a719713cfba07350dec71","modified":1458481892000},{"_id":"themes/Hacker/source/css/_partial/comment.css","hash":"14169821528fc921f950dcfb8eb83da9d8fce142","modified":1458391845000},{"_id":"themes/Hacker/source/css/_partial/comment.css~","hash":"a31681f4e1dfd0d39040e5206d1801c8ab7509d2","modified":1458391834000},{"_id":"themes/Hacker/source/css/_partial/footer.css","hash":"c8abedaff6f417eea84afa9526200d2f5abadb63","modified":1458481547000},{"_id":"themes/Hacker/source/css/_partial/footer.css~","hash":"7fb4e5cdb3e3c2403db21217cb03eaac468e7c16","modified":1458464647000},{"_id":"themes/Hacker/source/css/_partial/header.css","hash":"81428853e6690c76d0510923baf2ef4860f1a9ef","modified":1458392584000},{"_id":"themes/Hacker/source/css/_partial/header.css~","hash":"f72b7ca5b625b7fd37f0083228dcc9a91dbff3ad","modified":1458392549000},{"_id":"themes/Hacker/source/css/_partial/icon.css","hash":"d2088b77bcf619b2dd42990ec39323f16c444ada","modified":1458482198000},{"_id":"themes/Hacker/source/css/_partial/icon.css~","hash":"ed0b12629dbc49357701f7bb9064baba9caa43d1","modified":1458482187000},{"_id":"themes/Hacker/source/css/_partial/pagination.css","hash":"cf5d8b8d7c2d59fc16053c83e34fede0ab8c4ab9","modified":1458392363000},{"_id":"themes/Hacker/source/css/_partial/pagination.css~","hash":"045deddb4e04d0fbed416b1933e71e4623a06ace","modified":1458392344000},{"_id":"themes/Hacker/source/css/_partial/video.css","hash":"a594474ecaa89a3e724098c157e030057c8fcdd4","modified":1458275046000},{"_id":"themes/Hacker/.git/logs/refs/heads/master","hash":"151bef51c96b719215cb810453606d32e093436d","modified":1458275046000},{"_id":"themes/Hacker/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1458275046000},{"_id":"themes/Hacker/.git/logs/refs/remotes/origin/HEAD","hash":"151bef51c96b719215cb810453606d32e093436d","modified":1458275046000}],"Category":[{"name":"Android","_id":"cinisi4kb00063ntfmqi5sti6"},{"name":"Java","_id":"cinisi4kv000x3ntfnvxsfuzy"},{"name":"在线刷题","_id":"cinisi4l4001a3ntfculkzjqp"},{"name":"计算机基础","_id":"cinisi4l9001h3ntf6kok7w3a"}],"Data":[],"Page":[{"title":"关于我","date":"2015-12-31T16:00:00.000Z","_content":"<img src=\"mail.png\" width=\"16px\" height=\"16px\" style=\"margin: 7px auto;\"/> **E-mail: ** [wqd1993@qq.com](mailto:wqd1993@qq.com)\n<img src=\"github.png\" width=\"16px\" height=\"16px\" style=\"margin: 7px auto;\"/>  **Github: ** https://github.com/KevinWu1993\n<img src=\"weibo.png\" width=\"16px\" height=\"16px\" style=\"margin: 7px auto;\"/> **Weibo: ** http://weibo.com/505055373\n\n---\n\n# 吴启东\n\n基本信息：男 | 22岁 | 本科 | 江西师范大学 | 计算机信息工程学院 | 13级物联网工程\n籍贯：广东省茂名市\n职业方向：**Android 开发工程师**\n\n\n---\n\n## 技能\n\n* 熟悉Java SE编程\n* 熟悉Android应用开发流程，了解MVP模式\n* 熟悉Android UI控件和资源的使用，有一定开发自定义控件能力\n* 熟悉四大组件、多线程、AsyncTask、Json和XML解析、数据库开发等\n* 熟悉Android Studio、Eclipse开发工具\n* 熟悉SQLite Expert、SQL Server等数据库工具，熟练使用SQL语句\n* 熟悉通过Git进行版本控制和与他人合作开发\n* 熟悉技术文档的编写和软件开发需求分析的流程\n* 熟悉Photoshop图像处理、了解PHP，HTML等Web应用开发技术、了解Linux，能编写简单shell脚本\n* 了解基本数据结构算法\n* 良好的编码习惯\n* 英语四级，可阅读英文技术文档和简单日常交流，能通过stackoverflow、google等途径寻求问题的解决方法\n\n---\n\n## 项目经历\n\n### **考研英语Android版（2014年9月～2015年3月）**\n\n\n\n集合5年考研真题，并以”真题练习“、”专项练习“、”错题练习“、”随机练习“几个不同模块呈现出来。\n\n\n\n该项目作为校学术课题支持项目，得到校方的资助，在此项目中作为主要负责人，在指导老师的指导下，完成项目总体框架的设计，协调小组成员进行分工合作，完成主要模块的开发和部分技术文档的编写。该项目参加了2015年江西省作品赛获得了三等奖，并且在2015年结题后被评为校年度重点课题。\n\n\n\n### **芋头便签（2015年7月）**\n\n\n\n开发这款软件的初衷是自己有使用记事类软件记录一些瞬间灵感的习惯，希望有一个简单的记录文字的便签app。所以在2015年暑假担任培训讲师的工作之外抽时间开发了这个应用，在这个应用中仅仅用文本文件和SharedPreferences来处理数据存储问题，而且自定义了悬浮按钮控件和toolbar工具栏。\n\n\n\n这款应用目前已经上线国内应用商店。\n\n\n\n### **芋头天气（2015年8月）**\n\n\n\n这个应用中使用Material Design设计语言，并加入了个人对UI的独特见解，优化了RecyleView的使用体验，实现了地点滑动删除，拖动排序等交互逻辑，这个应用在应用商店发布后，UI和个性化简洁的风格得到了大多数用户的认可。\n\n\n\n这款天气软件使用百度车联网的天气源，目前已经进过两次版本更新，在一次收到来自台湾使用者反馈的问题后，还发现了百度的Api在针对台湾地区返回的温度信息中存在的问题。这个应用的新版将使用MVP模式开发，目前还在持续进行中。\n\n### **师大+（2015年12月至今）**\n\n\n\n这个应用集合了天气查询，教务信息，课程表，快递信息，校园生活信息，图书馆信息，自习室信息，学校新闻，知乎日报、果壳和简书的热门文章等功能。\n\n\n\n这也是我第一次使用GitHub在线上与同学合作开发的一个App，我负责需求分析、数据库设计、抓包分析数据源、解析数据和UI设计。除了提供外露api和使用同学提供的api外，还会阅读同学写的代码，出现bug时共同解决。参与了该项目从0开始的整个过程，目前还在功能完善中。\n\n\n\n---\n\n## 社会经历\n\n### **Android开发基础讲师（2015年7月～2015年8月）**\n\n\n\n在南昌联云科技有限公司担任为期一个月的Android开发基础讲师，带领学员从零java基础到开发出第一个Android应用。\n\n### **软件测试（2015年8月～2015年9月）**\n\n\n\n在南昌电信（信产部门），对照需求文档，对整体项目进行黑盒测试。\n\n\n\n---\n\n## 校内经历\n\n### **在OH团队主导Android开发（2014年9月至今）**\n\n\n\n在团队内指导部分团队成员学习Android开发，并负责完成相关项目。\n\n\n\n### **电脑爱好者协会 维修站站长（2014年9月～2015年6月）**\n\n\n\n负责培训部门成员解决电脑常见故障技巧，担任协会电脑知识讲座主讲。\n\n\n\n### **校智能机器人竞赛队（2015年9月～2015年12月）**\n\n\n\n在短时间内阅读未来伙伴机器人的API文档后，两周时间内用C语言与同学写出让场地机器人执行场地任务的代码，并成功工作起来，在后续调试中取得不错的成效。后来因为赛制更改，学校改报名搜救机器人项目，在12月初临时重写机器人的代码，在比赛前完成初版，并在2015年江西省智能机器人大赛中取得搜救组三等奖。\n\n\n\n---\n\n## 其他\n\n* 连续两年获得校年度综合素质奖学金\n\n* 2014年度文明大学生\n\n* 2015年度”飞尚科技奖学金“\n\n---\n\n## 自我评价\n\n热爱编程，热爱互联网，相信他们是驱动世界变得更美好的源泉。\n\n拥有较强的自我学习能力和适应能力，勇于迎接有意思的挑战。\n\n痴迷优美的UI，优雅的交互，常主动发掘小众但体验良好的app，思考具体实现和能改进的点。\n\n喜欢研究各种未知的东西，好奇心强，刷科技圈新闻也是每天必干。\n\n刷机，折腾ROM，也没少干。\n\n极客精神之外，喜欢运动，拿过乒乓球校运会冠军，跑步、羽毛球、篮球、登山。\n\n有阅读专业知识外的文学书籍阅读习惯。\n\n能吃苦，能担起重任，也喜欢团队合作完成细分任务。\n\n\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2016-01-01\n---\n<img src=\"mail.png\" width=\"16px\" height=\"16px\" style=\"margin: 7px auto;\"/> **E-mail: ** [wqd1993@qq.com](mailto:wqd1993@qq.com)\n<img src=\"github.png\" width=\"16px\" height=\"16px\" style=\"margin: 7px auto;\"/>  **Github: ** https://github.com/KevinWu1993\n<img src=\"weibo.png\" width=\"16px\" height=\"16px\" style=\"margin: 7px auto;\"/> **Weibo: ** http://weibo.com/505055373\n\n---\n\n# 吴启东\n\n基本信息：男 | 22岁 | 本科 | 江西师范大学 | 计算机信息工程学院 | 13级物联网工程\n籍贯：广东省茂名市\n职业方向：**Android 开发工程师**\n\n\n---\n\n## 技能\n\n* 熟悉Java SE编程\n* 熟悉Android应用开发流程，了解MVP模式\n* 熟悉Android UI控件和资源的使用，有一定开发自定义控件能力\n* 熟悉四大组件、多线程、AsyncTask、Json和XML解析、数据库开发等\n* 熟悉Android Studio、Eclipse开发工具\n* 熟悉SQLite Expert、SQL Server等数据库工具，熟练使用SQL语句\n* 熟悉通过Git进行版本控制和与他人合作开发\n* 熟悉技术文档的编写和软件开发需求分析的流程\n* 熟悉Photoshop图像处理、了解PHP，HTML等Web应用开发技术、了解Linux，能编写简单shell脚本\n* 了解基本数据结构算法\n* 良好的编码习惯\n* 英语四级，可阅读英文技术文档和简单日常交流，能通过stackoverflow、google等途径寻求问题的解决方法\n\n---\n\n## 项目经历\n\n### **考研英语Android版（2014年9月～2015年3月）**\n\n\n\n集合5年考研真题，并以”真题练习“、”专项练习“、”错题练习“、”随机练习“几个不同模块呈现出来。\n\n\n\n该项目作为校学术课题支持项目，得到校方的资助，在此项目中作为主要负责人，在指导老师的指导下，完成项目总体框架的设计，协调小组成员进行分工合作，完成主要模块的开发和部分技术文档的编写。该项目参加了2015年江西省作品赛获得了三等奖，并且在2015年结题后被评为校年度重点课题。\n\n\n\n### **芋头便签（2015年7月）**\n\n\n\n开发这款软件的初衷是自己有使用记事类软件记录一些瞬间灵感的习惯，希望有一个简单的记录文字的便签app。所以在2015年暑假担任培训讲师的工作之外抽时间开发了这个应用，在这个应用中仅仅用文本文件和SharedPreferences来处理数据存储问题，而且自定义了悬浮按钮控件和toolbar工具栏。\n\n\n\n这款应用目前已经上线国内应用商店。\n\n\n\n### **芋头天气（2015年8月）**\n\n\n\n这个应用中使用Material Design设计语言，并加入了个人对UI的独特见解，优化了RecyleView的使用体验，实现了地点滑动删除，拖动排序等交互逻辑，这个应用在应用商店发布后，UI和个性化简洁的风格得到了大多数用户的认可。\n\n\n\n这款天气软件使用百度车联网的天气源，目前已经进过两次版本更新，在一次收到来自台湾使用者反馈的问题后，还发现了百度的Api在针对台湾地区返回的温度信息中存在的问题。这个应用的新版将使用MVP模式开发，目前还在持续进行中。\n\n### **师大+（2015年12月至今）**\n\n\n\n这个应用集合了天气查询，教务信息，课程表，快递信息，校园生活信息，图书馆信息，自习室信息，学校新闻，知乎日报、果壳和简书的热门文章等功能。\n\n\n\n这也是我第一次使用GitHub在线上与同学合作开发的一个App，我负责需求分析、数据库设计、抓包分析数据源、解析数据和UI设计。除了提供外露api和使用同学提供的api外，还会阅读同学写的代码，出现bug时共同解决。参与了该项目从0开始的整个过程，目前还在功能完善中。\n\n\n\n---\n\n## 社会经历\n\n### **Android开发基础讲师（2015年7月～2015年8月）**\n\n\n\n在南昌联云科技有限公司担任为期一个月的Android开发基础讲师，带领学员从零java基础到开发出第一个Android应用。\n\n### **软件测试（2015年8月～2015年9月）**\n\n\n\n在南昌电信（信产部门），对照需求文档，对整体项目进行黑盒测试。\n\n\n\n---\n\n## 校内经历\n\n### **在OH团队主导Android开发（2014年9月至今）**\n\n\n\n在团队内指导部分团队成员学习Android开发，并负责完成相关项目。\n\n\n\n### **电脑爱好者协会 维修站站长（2014年9月～2015年6月）**\n\n\n\n负责培训部门成员解决电脑常见故障技巧，担任协会电脑知识讲座主讲。\n\n\n\n### **校智能机器人竞赛队（2015年9月～2015年12月）**\n\n\n\n在短时间内阅读未来伙伴机器人的API文档后，两周时间内用C语言与同学写出让场地机器人执行场地任务的代码，并成功工作起来，在后续调试中取得不错的成效。后来因为赛制更改，学校改报名搜救机器人项目，在12月初临时重写机器人的代码，在比赛前完成初版，并在2015年江西省智能机器人大赛中取得搜救组三等奖。\n\n\n\n---\n\n## 其他\n\n* 连续两年获得校年度综合素质奖学金\n\n* 2014年度文明大学生\n\n* 2015年度”飞尚科技奖学金“\n\n---\n\n## 自我评价\n\n热爱编程，热爱互联网，相信他们是驱动世界变得更美好的源泉。\n\n拥有较强的自我学习能力和适应能力，勇于迎接有意思的挑战。\n\n痴迷优美的UI，优雅的交互，常主动发掘小众但体验良好的app，思考具体实现和能改进的点。\n\n喜欢研究各种未知的东西，好奇心强，刷科技圈新闻也是每天必干。\n\n刷机，折腾ROM，也没少干。\n\n极客精神之外，喜欢运动，拿过乒乓球校运会冠军，跑步、羽毛球、篮球、登山。\n\n有阅读专业知识外的文学书籍阅读习惯。\n\n能吃苦，能担起重任，也喜欢团队合作完成细分任务。\n\n\n\n","updated":"2016-03-20T13:41:47.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cinisi4hk00003ntfvfofqtle","content":"<p><img src=\"mail.png\" width=\"16px\" height=\"16px\" style=\"margin: 7px auto;\"> <strong>E-mail: </strong> <a href=\"mailto:wqd1993@qq.com\" target=\"_blank\" rel=\"external\">wqd1993@qq.com</a><br><img src=\"github.png\" width=\"16px\" height=\"16px\" style=\"margin: 7px auto;\">  <strong>Github: </strong> <a href=\"https://github.com/KevinWu1993\" target=\"_blank\" rel=\"external\">https://github.com/KevinWu1993</a><br><img src=\"weibo.png\" width=\"16px\" height=\"16px\" style=\"margin: 7px auto;\"> <strong>Weibo: </strong> <a href=\"http://weibo.com/505055373\" target=\"_blank\" rel=\"external\">http://weibo.com/505055373</a></p>\n<hr>\n<h1 id=\"吴启东\"><a href=\"#吴启东\" class=\"headerlink\" title=\"吴启东\"></a>吴启东</h1><p>基本信息：男 | 22岁 | 本科 | 江西师范大学 | 计算机信息工程学院 | 13级物联网工程<br>籍贯：广东省茂名市<br>职业方向：<strong>Android 开发工程师</strong></p>\n<hr>\n<h2 id=\"技能\"><a href=\"#技能\" class=\"headerlink\" title=\"技能\"></a>技能</h2><ul>\n<li>熟悉Java SE编程</li>\n<li>熟悉Android应用开发流程，了解MVP模式</li>\n<li>熟悉Android UI控件和资源的使用，有一定开发自定义控件能力</li>\n<li>熟悉四大组件、多线程、AsyncTask、Json和XML解析、数据库开发等</li>\n<li>熟悉Android Studio、Eclipse开发工具</li>\n<li>熟悉SQLite Expert、SQL Server等数据库工具，熟练使用SQL语句</li>\n<li>熟悉通过Git进行版本控制和与他人合作开发</li>\n<li>熟悉技术文档的编写和软件开发需求分析的流程</li>\n<li>熟悉Photoshop图像处理、了解PHP，HTML等Web应用开发技术、了解Linux，能编写简单shell脚本</li>\n<li>了解基本数据结构算法</li>\n<li>良好的编码习惯</li>\n<li>英语四级，可阅读英文技术文档和简单日常交流，能通过stackoverflow、google等途径寻求问题的解决方法</li>\n</ul>\n<hr>\n<h2 id=\"项目经历\"><a href=\"#项目经历\" class=\"headerlink\" title=\"项目经历\"></a>项目经历</h2><h3 id=\"考研英语Android版（2014年9月～2015年3月）\"><a href=\"#考研英语Android版（2014年9月～2015年3月）\" class=\"headerlink\" title=\"考研英语Android版（2014年9月～2015年3月）\"></a><strong>考研英语Android版（2014年9月～2015年3月）</strong></h3><p>集合5年考研真题，并以”真题练习“、”专项练习“、”错题练习“、”随机练习“几个不同模块呈现出来。</p>\n<p>该项目作为校学术课题支持项目，得到校方的资助，在此项目中作为主要负责人，在指导老师的指导下，完成项目总体框架的设计，协调小组成员进行分工合作，完成主要模块的开发和部分技术文档的编写。该项目参加了2015年江西省作品赛获得了三等奖，并且在2015年结题后被评为校年度重点课题。</p>\n<h3 id=\"芋头便签（2015年7月）\"><a href=\"#芋头便签（2015年7月）\" class=\"headerlink\" title=\"芋头便签（2015年7月）\"></a><strong>芋头便签（2015年7月）</strong></h3><p>开发这款软件的初衷是自己有使用记事类软件记录一些瞬间灵感的习惯，希望有一个简单的记录文字的便签app。所以在2015年暑假担任培训讲师的工作之外抽时间开发了这个应用，在这个应用中仅仅用文本文件和SharedPreferences来处理数据存储问题，而且自定义了悬浮按钮控件和toolbar工具栏。</p>\n<p>这款应用目前已经上线国内应用商店。</p>\n<h3 id=\"芋头天气（2015年8月）\"><a href=\"#芋头天气（2015年8月）\" class=\"headerlink\" title=\"芋头天气（2015年8月）\"></a><strong>芋头天气（2015年8月）</strong></h3><p>这个应用中使用Material Design设计语言，并加入了个人对UI的独特见解，优化了RecyleView的使用体验，实现了地点滑动删除，拖动排序等交互逻辑，这个应用在应用商店发布后，UI和个性化简洁的风格得到了大多数用户的认可。</p>\n<p>这款天气软件使用百度车联网的天气源，目前已经进过两次版本更新，在一次收到来自台湾使用者反馈的问题后，还发现了百度的Api在针对台湾地区返回的温度信息中存在的问题。这个应用的新版将使用MVP模式开发，目前还在持续进行中。</p>\n<h3 id=\"师大-（2015年12月至今）\"><a href=\"#师大-（2015年12月至今）\" class=\"headerlink\" title=\"师大+（2015年12月至今）\"></a><strong>师大+（2015年12月至今）</strong></h3><p>这个应用集合了天气查询，教务信息，课程表，快递信息，校园生活信息，图书馆信息，自习室信息，学校新闻，知乎日报、果壳和简书的热门文章等功能。</p>\n<p>这也是我第一次使用GitHub在线上与同学合作开发的一个App，我负责需求分析、数据库设计、抓包分析数据源、解析数据和UI设计。除了提供外露api和使用同学提供的api外，还会阅读同学写的代码，出现bug时共同解决。参与了该项目从0开始的整个过程，目前还在功能完善中。</p>\n<hr>\n<h2 id=\"社会经历\"><a href=\"#社会经历\" class=\"headerlink\" title=\"社会经历\"></a>社会经历</h2><h3 id=\"Android开发基础讲师（2015年7月～2015年8月）\"><a href=\"#Android开发基础讲师（2015年7月～2015年8月）\" class=\"headerlink\" title=\"Android开发基础讲师（2015年7月～2015年8月）\"></a><strong>Android开发基础讲师（2015年7月～2015年8月）</strong></h3><p>在南昌联云科技有限公司担任为期一个月的Android开发基础讲师，带领学员从零java基础到开发出第一个Android应用。</p>\n<h3 id=\"软件测试（2015年8月～2015年9月）\"><a href=\"#软件测试（2015年8月～2015年9月）\" class=\"headerlink\" title=\"软件测试（2015年8月～2015年9月）\"></a><strong>软件测试（2015年8月～2015年9月）</strong></h3><p>在南昌电信（信产部门），对照需求文档，对整体项目进行黑盒测试。</p>\n<hr>\n<h2 id=\"校内经历\"><a href=\"#校内经历\" class=\"headerlink\" title=\"校内经历\"></a>校内经历</h2><h3 id=\"在OH团队主导Android开发（2014年9月至今）\"><a href=\"#在OH团队主导Android开发（2014年9月至今）\" class=\"headerlink\" title=\"在OH团队主导Android开发（2014年9月至今）\"></a><strong>在OH团队主导Android开发（2014年9月至今）</strong></h3><p>在团队内指导部分团队成员学习Android开发，并负责完成相关项目。</p>\n<h3 id=\"电脑爱好者协会-维修站站长（2014年9月～2015年6月）\"><a href=\"#电脑爱好者协会-维修站站长（2014年9月～2015年6月）\" class=\"headerlink\" title=\"电脑爱好者协会 维修站站长（2014年9月～2015年6月）\"></a><strong>电脑爱好者协会 维修站站长（2014年9月～2015年6月）</strong></h3><p>负责培训部门成员解决电脑常见故障技巧，担任协会电脑知识讲座主讲。</p>\n<h3 id=\"校智能机器人竞赛队（2015年9月～2015年12月）\"><a href=\"#校智能机器人竞赛队（2015年9月～2015年12月）\" class=\"headerlink\" title=\"校智能机器人竞赛队（2015年9月～2015年12月）\"></a><strong>校智能机器人竞赛队（2015年9月～2015年12月）</strong></h3><p>在短时间内阅读未来伙伴机器人的API文档后，两周时间内用C语言与同学写出让场地机器人执行场地任务的代码，并成功工作起来，在后续调试中取得不错的成效。后来因为赛制更改，学校改报名搜救机器人项目，在12月初临时重写机器人的代码，在比赛前完成初版，并在2015年江西省智能机器人大赛中取得搜救组三等奖。</p>\n<hr>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li><p>连续两年获得校年度综合素质奖学金</p>\n</li>\n<li><p>2014年度文明大学生</p>\n</li>\n<li><p>2015年度”飞尚科技奖学金“</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"自我评价\"><a href=\"#自我评价\" class=\"headerlink\" title=\"自我评价\"></a>自我评价</h2><p>热爱编程，热爱互联网，相信他们是驱动世界变得更美好的源泉。</p>\n<p>拥有较强的自我学习能力和适应能力，勇于迎接有意思的挑战。</p>\n<p>痴迷优美的UI，优雅的交互，常主动发掘小众但体验良好的app，思考具体实现和能改进的点。</p>\n<p>喜欢研究各种未知的东西，好奇心强，刷科技圈新闻也是每天必干。</p>\n<p>刷机，折腾ROM，也没少干。</p>\n<p>极客精神之外，喜欢运动，拿过乒乓球校运会冠军，跑步、羽毛球、篮球、登山。</p>\n<p>有阅读专业知识外的文学书籍阅读习惯。</p>\n<p>能吃苦，能担起重任，也喜欢团队合作完成细分任务。</p>\n","excerpt":"","more":"<p><img src=\"mail.png\" width=\"16px\" height=\"16px\" style=\"margin: 7px auto;\"/> <strong>E-mail: </strong> <a href=\"mailto:wqd1993@qq.com\">wqd1993@qq.com</a><br><img src=\"github.png\" width=\"16px\" height=\"16px\" style=\"margin: 7px auto;\"/>  <strong>Github: </strong> <a href=\"https://github.com/KevinWu1993\">https://github.com/KevinWu1993</a><br><img src=\"weibo.png\" width=\"16px\" height=\"16px\" style=\"margin: 7px auto;\"/> <strong>Weibo: </strong> <a href=\"http://weibo.com/505055373\">http://weibo.com/505055373</a></p>\n<hr>\n<h1 id=\"吴启东\"><a href=\"#吴启东\" class=\"headerlink\" title=\"吴启东\"></a>吴启东</h1><p>基本信息：男 | 22岁 | 本科 | 江西师范大学 | 计算机信息工程学院 | 13级物联网工程<br>籍贯：广东省茂名市<br>职业方向：<strong>Android 开发工程师</strong></p>\n<hr>\n<h2 id=\"技能\"><a href=\"#技能\" class=\"headerlink\" title=\"技能\"></a>技能</h2><ul>\n<li>熟悉Java SE编程</li>\n<li>熟悉Android应用开发流程，了解MVP模式</li>\n<li>熟悉Android UI控件和资源的使用，有一定开发自定义控件能力</li>\n<li>熟悉四大组件、多线程、AsyncTask、Json和XML解析、数据库开发等</li>\n<li>熟悉Android Studio、Eclipse开发工具</li>\n<li>熟悉SQLite Expert、SQL Server等数据库工具，熟练使用SQL语句</li>\n<li>熟悉通过Git进行版本控制和与他人合作开发</li>\n<li>熟悉技术文档的编写和软件开发需求分析的流程</li>\n<li>熟悉Photoshop图像处理、了解PHP，HTML等Web应用开发技术、了解Linux，能编写简单shell脚本</li>\n<li>了解基本数据结构算法</li>\n<li>良好的编码习惯</li>\n<li>英语四级，可阅读英文技术文档和简单日常交流，能通过stackoverflow、google等途径寻求问题的解决方法</li>\n</ul>\n<hr>\n<h2 id=\"项目经历\"><a href=\"#项目经历\" class=\"headerlink\" title=\"项目经历\"></a>项目经历</h2><h3 id=\"考研英语Android版（2014年9月～2015年3月）\"><a href=\"#考研英语Android版（2014年9月～2015年3月）\" class=\"headerlink\" title=\"考研英语Android版（2014年9月～2015年3月）\"></a><strong>考研英语Android版（2014年9月～2015年3月）</strong></h3><p>集合5年考研真题，并以”真题练习“、”专项练习“、”错题练习“、”随机练习“几个不同模块呈现出来。</p>\n<p>该项目作为校学术课题支持项目，得到校方的资助，在此项目中作为主要负责人，在指导老师的指导下，完成项目总体框架的设计，协调小组成员进行分工合作，完成主要模块的开发和部分技术文档的编写。该项目参加了2015年江西省作品赛获得了三等奖，并且在2015年结题后被评为校年度重点课题。</p>\n<h3 id=\"芋头便签（2015年7月）\"><a href=\"#芋头便签（2015年7月）\" class=\"headerlink\" title=\"芋头便签（2015年7月）\"></a><strong>芋头便签（2015年7月）</strong></h3><p>开发这款软件的初衷是自己有使用记事类软件记录一些瞬间灵感的习惯，希望有一个简单的记录文字的便签app。所以在2015年暑假担任培训讲师的工作之外抽时间开发了这个应用，在这个应用中仅仅用文本文件和SharedPreferences来处理数据存储问题，而且自定义了悬浮按钮控件和toolbar工具栏。</p>\n<p>这款应用目前已经上线国内应用商店。</p>\n<h3 id=\"芋头天气（2015年8月）\"><a href=\"#芋头天气（2015年8月）\" class=\"headerlink\" title=\"芋头天气（2015年8月）\"></a><strong>芋头天气（2015年8月）</strong></h3><p>这个应用中使用Material Design设计语言，并加入了个人对UI的独特见解，优化了RecyleView的使用体验，实现了地点滑动删除，拖动排序等交互逻辑，这个应用在应用商店发布后，UI和个性化简洁的风格得到了大多数用户的认可。</p>\n<p>这款天气软件使用百度车联网的天气源，目前已经进过两次版本更新，在一次收到来自台湾使用者反馈的问题后，还发现了百度的Api在针对台湾地区返回的温度信息中存在的问题。这个应用的新版将使用MVP模式开发，目前还在持续进行中。</p>\n<h3 id=\"师大-（2015年12月至今）\"><a href=\"#师大-（2015年12月至今）\" class=\"headerlink\" title=\"师大+（2015年12月至今）\"></a><strong>师大+（2015年12月至今）</strong></h3><p>这个应用集合了天气查询，教务信息，课程表，快递信息，校园生活信息，图书馆信息，自习室信息，学校新闻，知乎日报、果壳和简书的热门文章等功能。</p>\n<p>这也是我第一次使用GitHub在线上与同学合作开发的一个App，我负责需求分析、数据库设计、抓包分析数据源、解析数据和UI设计。除了提供外露api和使用同学提供的api外，还会阅读同学写的代码，出现bug时共同解决。参与了该项目从0开始的整个过程，目前还在功能完善中。</p>\n<hr>\n<h2 id=\"社会经历\"><a href=\"#社会经历\" class=\"headerlink\" title=\"社会经历\"></a>社会经历</h2><h3 id=\"Android开发基础讲师（2015年7月～2015年8月）\"><a href=\"#Android开发基础讲师（2015年7月～2015年8月）\" class=\"headerlink\" title=\"Android开发基础讲师（2015年7月～2015年8月）\"></a><strong>Android开发基础讲师（2015年7月～2015年8月）</strong></h3><p>在南昌联云科技有限公司担任为期一个月的Android开发基础讲师，带领学员从零java基础到开发出第一个Android应用。</p>\n<h3 id=\"软件测试（2015年8月～2015年9月）\"><a href=\"#软件测试（2015年8月～2015年9月）\" class=\"headerlink\" title=\"软件测试（2015年8月～2015年9月）\"></a><strong>软件测试（2015年8月～2015年9月）</strong></h3><p>在南昌电信（信产部门），对照需求文档，对整体项目进行黑盒测试。</p>\n<hr>\n<h2 id=\"校内经历\"><a href=\"#校内经历\" class=\"headerlink\" title=\"校内经历\"></a>校内经历</h2><h3 id=\"在OH团队主导Android开发（2014年9月至今）\"><a href=\"#在OH团队主导Android开发（2014年9月至今）\" class=\"headerlink\" title=\"在OH团队主导Android开发（2014年9月至今）\"></a><strong>在OH团队主导Android开发（2014年9月至今）</strong></h3><p>在团队内指导部分团队成员学习Android开发，并负责完成相关项目。</p>\n<h3 id=\"电脑爱好者协会-维修站站长（2014年9月～2015年6月）\"><a href=\"#电脑爱好者协会-维修站站长（2014年9月～2015年6月）\" class=\"headerlink\" title=\"电脑爱好者协会 维修站站长（2014年9月～2015年6月）\"></a><strong>电脑爱好者协会 维修站站长（2014年9月～2015年6月）</strong></h3><p>负责培训部门成员解决电脑常见故障技巧，担任协会电脑知识讲座主讲。</p>\n<h3 id=\"校智能机器人竞赛队（2015年9月～2015年12月）\"><a href=\"#校智能机器人竞赛队（2015年9月～2015年12月）\" class=\"headerlink\" title=\"校智能机器人竞赛队（2015年9月～2015年12月）\"></a><strong>校智能机器人竞赛队（2015年9月～2015年12月）</strong></h3><p>在短时间内阅读未来伙伴机器人的API文档后，两周时间内用C语言与同学写出让场地机器人执行场地任务的代码，并成功工作起来，在后续调试中取得不错的成效。后来因为赛制更改，学校改报名搜救机器人项目，在12月初临时重写机器人的代码，在比赛前完成初版，并在2015年江西省智能机器人大赛中取得搜救组三等奖。</p>\n<hr>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li><p>连续两年获得校年度综合素质奖学金</p>\n</li>\n<li><p>2014年度文明大学生</p>\n</li>\n<li><p>2015年度”飞尚科技奖学金“</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"自我评价\"><a href=\"#自我评价\" class=\"headerlink\" title=\"自我评价\"></a>自我评价</h2><p>热爱编程，热爱互联网，相信他们是驱动世界变得更美好的源泉。</p>\n<p>拥有较强的自我学习能力和适应能力，勇于迎接有意思的挑战。</p>\n<p>痴迷优美的UI，优雅的交互，常主动发掘小众但体验良好的app，思考具体实现和能改进的点。</p>\n<p>喜欢研究各种未知的东西，好奇心强，刷科技圈新闻也是每天必干。</p>\n<p>刷机，折腾ROM，也没少干。</p>\n<p>极客精神之外，喜欢运动，拿过乒乓球校运会冠军，跑步、羽毛球、篮球、登山。</p>\n<p>有阅读专业知识外的文学书籍阅读习惯。</p>\n<p>能吃苦，能担起重任，也喜欢团队合作完成细分任务。</p>\n"},{"title":"分类","layout":"categories","_content":"\n","source":"categories/index.md","raw":"title: \"分类\"\nlayout: \"categories\"\n---\n\n","date":"2016-04-27T11:36:31.000Z","updated":"2016-03-20T13:31:41.000Z","path":"categories/index.html","comments":1,"_id":"cinisi4hm00013ntfdylifglz","content":"","excerpt":"","more":""},{"title":"链接","date":"2015-12-31T16:00:00.000Z","_content":"\n- [江西师范大学](http://www.jxnu.edu.cn/)\n\n- [MummyDing](http://blog.csdn.net/mummyding)\n\n- [刀刀的博客](https://ddragonever.github.io)","source":"link/index.md","raw":"---\ntitle: 链接\ndate: 2016-01-01\n---\n\n- [江西师范大学](http://www.jxnu.edu.cn/)\n\n- [MummyDing](http://blog.csdn.net/mummyding)\n\n- [刀刀的博客](https://ddragonever.github.io)","updated":"2016-03-20T02:49:58.000Z","path":"link/index.html","comments":1,"layout":"page","_id":"cinisi4hn00023ntfhtehc41e","content":"<ul>\n<li><p><a href=\"http://www.jxnu.edu.cn/\" target=\"_blank\" rel=\"external\">江西师范大学</a></p>\n</li>\n<li><p><a href=\"http://blog.csdn.net/mummyding\" target=\"_blank\" rel=\"external\">MummyDing</a></p>\n</li>\n<li><p><a href=\"https://ddragonever.github.io\" target=\"_blank\" rel=\"external\">刀刀的博客</a></p>\n</li>\n</ul>\n","excerpt":"","more":"<ul>\n<li><p><a href=\"http://www.jxnu.edu.cn/\">江西师范大学</a></p>\n</li>\n<li><p><a href=\"http://blog.csdn.net/mummyding\">MummyDing</a></p>\n</li>\n<li><p><a href=\"https://ddragonever.github.io\">刀刀的博客</a></p>\n</li>\n</ul>\n"},{"title":"Tags","layout":"tags","_content":"\n","source":"tags/index.md","raw":"title: \"Tags\"\nlayout: \"tags\"\n---\n\n","date":"2016-04-27T11:36:31.000Z","updated":"2016-03-20T11:53:50.000Z","path":"tags/index.html","comments":1,"_id":"cinisi4hp00033ntfu6xhklwa","content":"","excerpt":"","more":""}],"Post":[{"title":"Gson学习笔记","date":"2016-01-29T16:00:00.000Z","author":"KevinWu","_content":"## Gson是什么\n要了解Gson是什么，恐怕得先说一下Json这个东西\n（Json的背景知识就直接引用网络上的了http://www.open-open.com/lib/view/open1407376535942.html）。\n### 什么是Json\nJSON即JavaScript Object Natation, 它是一种轻量级的数据交换格式, 与XML一样, 是广泛被采用的客户端和服务端交互的解决方案.\n<!--more-->\n### Json对象\nJSON中对象(Object)以\"{\"开始, 以\"}\"结束. 对象中的每一个item都是一个key-value对, 表现为\"key:value\"的形式, key-value对之间使用逗号分隔. 如:{\"name\":\"coolxing\", \"age\"=24, \"male\":true, \"address\":{\"street\":\"huiLongGuan\", \"city\":\"beijing\", \"country\":\"china\"}}. JSON对象的key只能是string类型的, 而value可以是string, number, false, true, null, Object对象甚至是array数组, 也就是说可以存在嵌套的情况.\n### Json数组\nJSON数组(array)以\"[\"开始, 以\"]\"结束, 数组中的每一个元素可以是string, number, false, true, null, Object对象甚至是array数组, 数组间的元素使用逗号分隔. 如[\"coolxing\", 24, {\"street\":\"huiLongGuan\", \"city\":\"beijing\", \"country\":\"china\"}].\n\n好了Json的基本背景介绍完了，先看看一个天气Api返回的Json对象吧（截取部分）。\n完整的json返回数据示例地址：https://github.com/KevinWu1993/YTWeatherPro/blob/dev/doc/%E5%AE%8C%E6%95%B4json%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE.md\n\n```\n{\n    \"reason\": \"查询成功\",\n    \"result\": {\n        \"data\": {\n            \"realtime\": {\n                \"city_code\": \"101210701\",\n                \"city_name\": \"温州\",     /*城市*/\n                \"date\": \"2014-10-15\",  /*日期*/\n                \"time\": \"09:00:00\",     /*更新时间*/\n                \"week\": 3,\n                \"moon\": \"九月廿二\",\n                \"dataUptime\": 1413337811,\n                \"weather\": {    /*当前实况天气*/\n                    \"temperature\": \"19\",     /*温度*/\n                    \"humidity\": \"54\",     /*湿度*/\n                    \"info\": \"雾\",\n                    \"img\": \"18\"\n                },\n                \"wind\": {\n                    \"direct\": \"北风\",\n                    \"power\": \"1级\",\n                    \"offset\": null,\n                    \"windspeed\": null\n                }\n            },\n            \"life\": {     /*生活指数*/\n                \"date\": \"2014-10-15\",\n                \"info\": {\n                    \"chuanyi\": [     /*穿衣指数*/\n                        \"较舒适\",\n                        \"建议着薄外套或牛仔衫裤等服装。年老体弱者宜着夹克衫、薄毛衣等。昼夜温差较大，注意适当增减衣服。\"\n                    ],\n                    \"ganmao\": [    /*感冒指数*/\n                        \"较易发\",\n                        \"昼夜温差较大，较易发生感冒，请适当增减衣服。体质较弱的朋友请注意防护。\"\n                    ],\n                    \"kongtiao\": [   /*空调指数*/\n                        \"较少开启\",\n                        \"您将感到很舒适，一般不需要开启空调。\"\n                    ],\n                    \"wuran\": [     /*污染指数*/\n                        \"良\",\n                        \"气象条件有利于空气污染物稀释、扩散和清除，可在室外正常活动。\"\n                    ],\n                    \"xiche\": [     /*洗车指数*/\n                        \"较适宜\",\n                        \"较适宜洗车，未来一天无雨，风力较小，擦洗一新的汽车至少能保持一天。\"\n                    ],\n                    \"yundong\": [     /*运动指数*/\n                        \"较适宜\",\n                        \"天气较好，但风力较大，推荐您进行室内运动，若在户外运动请注意防风。\"\n                    ],\n                    \"ziwaixian\": [   /*紫外线*/\n                        \"中等\",\n                        \"属中等强度紫外线辐射天气，外出时建议涂擦SPF高于15、PA+的防晒护肤品，戴帽子、太阳镜。\"\n                    ]\n                }\n            },\n         ............\n```\n上面是天气Api返回的json对象，之前开发中是用org.json工具进行解析的，可能我对那个工具也没有参悟得很透彻，我感觉我用的是最笨的方法，下面给出一小段之前写的解析代码：\n```java\n//取得result根\n JSONObject jsonresult = new JSONObject(value);\n String resultSTR = jsonresult.getString(\"result\");\n \n //取得DATA根\n JSONObject jsonDATA = new JSONObject(resultSTR);\n String dataSTR = jsonDATA.getString(\"data\");\n \n//取得realtime根\n JSONObject jsonRT = new JSONObject(dataSTR);\n String rtSTR = jsonRT.getString(\"realtime\");\nJSONObject jsonRealTime = new JSONObject(rtSTR);//这个是realtime的json对象\nString city = jsonRealTime.getString(\"city_name\"); //取得城市名称\n String updatetime = jsonRealTime.getString(\"date\") + \" \" + jsonRealTime.getString(\"time\");//获得更新时间，即为返回的数据的日期加更新具体时间\n```\n好了！废话说了这么多，该谈谈Gson了，回到那个问题，Gson是什么？\n其实也就是一个工具。\n\n---\n\n## 使用Gson前准备工作\n要使用它，我们要先下载它的依赖包，可以直接去github开源项目地址下载：https://github.com/google/gson\n我也搬运过来了，直接去下载也可以：http://download.csdn.net/detail/kevinwu93/9422464\n\n下载后，我们需要在工程项目中依赖它这个jar包，以Android Studio为例，可以放到module中的libs目录下，如下图所示：\n![这里写图片描述](http://img.blog.csdn.net/20160130141817334)\n接下来还需要在gradle文件中添加依赖语句\n```\ncompile files('libs/gson-2.5.jar')\n```\n\n这样，我们就导入这个工具了，接下来就可以使用了。\n\n---\n\n## 正式使用Gson\n这里主要讨论使用Gson的fromJson()方法解析Json字符串，获取相应的数据，至于toJson()方法，以后应该还会写篇文章。\n\n先来看看fromJson()这个方法：\nfromJson()这个方法的用法如下：\n```java\nnew Gson().fromJson(Json_string,class)\n```\n\n参数需要json字符串和一个实体，所以下面先来针对以上天气的返回数据创建一个实体：\n```java\npublic class WeatherEntity {\n    public String reason;\n    public ResultEntity result;\n    public int error_code;//错误码\n}\n```\n\n在这个天气实体中我分成了三部分，第一部分为一个字符串，对应返回的json数据的reason字段：\n```\n\"reason\": \"查询成功\"\n```\n\n最后的error_code对应json数据中的error_code字段：\n```\n\"error_code\": 0\n```\n\n下面说一下中中间的public ResultEntity result;这个实体类型\n因为返回的result字段的数据比较复杂，所以继续细分出来，先看看ResultEntityEntity这个类的代码：\n```java\npublic class ResultEntity {\n    public DataEntity data;\n}\n```\n\n因为result中又包含了一个data字段，所有我再分了一层，再来看看DataEntity部分的代码\n``` java\npublic class DataEntity {\n    public RealtimeEntity realtime;\n    public LifeEntity life;\n    public ArrayList<AdayWeatherEntity> weather=new ArrayList<AdayWeatherEntity>();\n    public Pm25Entity pm25;\n    public int date;\n    public int isForeign;\n}\n```\n\n分析这段代码前，先看一下返回的json的数据的结构（建议参照完整json数据返回内容）：\n```\n          \"realtime\": {\n                \"city_code\": \"101210701\",\n                \"city_name\": \"温州\",     /*城市*/\n                \"date\": \"2014-10-15\",  /*日期*/\n                \"time\": \"09:00:00\",     /*更新时间*/\n                 ............................省略\n            },\n            \"life\": {     /*生活指数*/\n                \"date\": \"2014-10-15\",\n                \"info\": {\n                    \"chuanyi\": [     /*穿衣指数*/\n                        \"较舒适\",\n                        \"建议着薄外套或牛仔衫裤等服装。年老体弱者宜着夹克衫、薄毛衣等。昼夜温差较大，注意适当增减衣服。\"\n                    ],\n                   ............................省略\n            },\n            \"weather\": [   /*未来几天天气预报*/\n                {\n                    \"date\": \"2014-10-15\",\n                    \"info\": {\n                        \"day\": [     /*白天天气*/\n               ............................省略\n            ],\n            \"pm25\": {    /*PM2.5*/\n                \"key\": \"Wenzhou\",\n                \"show_desc\": 0,\n                \"pm25\": {\n                    \"curPm\": \"97\",\n                    \"pm25\": \"72\",\n                    \"pm10\": \"97\",\n                    \"level\": 2,\n                    \"quality\": \"良\",\n                    \"des\": \"可以接受的，除极少数对某种污染物特别敏感的人以外，对公众健康没有危害。\"\n                },\n                \"dateTime\": \"2014年10月15日09时\",\n                \"cityName\": \"温州\"\n            },\n            \"date\": null,\n            \"isForeign\": 0\n```\n\n可以看到这里有几大字段，分别为：\n- realtime\n- life\n- weather\n- pm25\n- date\n- isForeign\n\n对于date和isForeign这两个字段来说，单一数据，可以直接用对应的数据类型做实体，解析很简单。\n对应realtime等类型的数据，结构相对来说还是比较复杂的，这里再单独出来进行解析，就用realtime做例子，其它的有需要可以参考github上项目的完整代码，这里不详细说明。\n先来看看RealtimeEntity这个类：\n``` java\npublic class RealtimeEntity {\n    public String city_code;//城市代码\n    public String city_name;//城市名称\n    public String date;//日期\n    public String time;//更新时间\n    public int week;//星期\n    public String moon;//农历、\n    public long dataUptime;//更新时间戳\n    public RealTimeWeatherEntity weather;//实时天气实体\n    public RealtimeWindEntity wind;//风速风力信息实体\n}\n```\n\n对于单一数据没嵌套的直接解析，对于还有嵌套的，继续细分，接下来看看RealTimeWeatherEntity和RealtimeWindEntity这两个类：\n```java\npublic class RealTimeWeatherEntity {\n    public String tempertrue;//实时温度\n    public String humidity;//湿度\n    public String info;//天气信息\n    public String img;//天气对应图片\n}\n```\n\n```java\npublic class RealtimeWindEntity {\n    public String direct;//风向\n    public String power;//风力\n    public String offset;//风向偏移量\n    public String windspeed;//风速\n}\n```\n这两个类都只是对数据进行定义，相当于把json中的数据一一对应地描述出来，这样进行了多层细分后，realtime这个字段返回的数据就每个都有了对应的变量来描述，其他的也同样道理，在对所有的数据进行实体定义后，就可以调用Gson方法进行解析了，解析部分的代码如下（我把测试的json数据放在个txt文件里面了）：\n```java\n/**\n    *测试gson实体\n    *@author KevinWu\n    *create at 2016/1/29 22:15\n    */\n    @Test\n    public void testEntity(){\n        String jsonStr=importStr();//导入要测试的数据\n        System.out.println(jsonStr);\n        Gson gson=new Gson();\n        WeatherEntity w=gson.fromJson(jsonStr,WeatherEntity.class);\n        System.out.println(w.result.data.pm25.pm25.pm10);\n    }\n \n    private String importStr(){\n        String str=\"\";\n        File myFile=new File(\"./json_test.txt\");\n        try {\n            FileReader myFileReader=new FileReader(myFile);\n            BufferedReader myBufferedReader=new BufferedReader(myFileReader);\n            String temp;\n            while((temp=myBufferedReader.readLine())!=null){\n                str=str+temp;\n            }\n            myBufferedReader.close();\n            myFileReader.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n```\n\n就这样。\n\nGithub项目地址：https://github.com/KevinWu1993/YTWeatherPro\n\n\n\n","source":"_posts/Android/201601/Gson学习笔记.md","raw":"---\ntitle: Gson学习笔记\ndate: 2016-01-30 \nauthor:  KevinWu\ncategories: Android\ntags: \n\t- Java \n\t- Android\n\t- Gson\n\t- Json\n\t- 解析\n---\n## Gson是什么\n要了解Gson是什么，恐怕得先说一下Json这个东西\n（Json的背景知识就直接引用网络上的了http://www.open-open.com/lib/view/open1407376535942.html）。\n### 什么是Json\nJSON即JavaScript Object Natation, 它是一种轻量级的数据交换格式, 与XML一样, 是广泛被采用的客户端和服务端交互的解决方案.\n<!--more-->\n### Json对象\nJSON中对象(Object)以\"{\"开始, 以\"}\"结束. 对象中的每一个item都是一个key-value对, 表现为\"key:value\"的形式, key-value对之间使用逗号分隔. 如:{\"name\":\"coolxing\", \"age\"=24, \"male\":true, \"address\":{\"street\":\"huiLongGuan\", \"city\":\"beijing\", \"country\":\"china\"}}. JSON对象的key只能是string类型的, 而value可以是string, number, false, true, null, Object对象甚至是array数组, 也就是说可以存在嵌套的情况.\n### Json数组\nJSON数组(array)以\"[\"开始, 以\"]\"结束, 数组中的每一个元素可以是string, number, false, true, null, Object对象甚至是array数组, 数组间的元素使用逗号分隔. 如[\"coolxing\", 24, {\"street\":\"huiLongGuan\", \"city\":\"beijing\", \"country\":\"china\"}].\n\n好了Json的基本背景介绍完了，先看看一个天气Api返回的Json对象吧（截取部分）。\n完整的json返回数据示例地址：https://github.com/KevinWu1993/YTWeatherPro/blob/dev/doc/%E5%AE%8C%E6%95%B4json%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE.md\n\n```\n{\n    \"reason\": \"查询成功\",\n    \"result\": {\n        \"data\": {\n            \"realtime\": {\n                \"city_code\": \"101210701\",\n                \"city_name\": \"温州\",     /*城市*/\n                \"date\": \"2014-10-15\",  /*日期*/\n                \"time\": \"09:00:00\",     /*更新时间*/\n                \"week\": 3,\n                \"moon\": \"九月廿二\",\n                \"dataUptime\": 1413337811,\n                \"weather\": {    /*当前实况天气*/\n                    \"temperature\": \"19\",     /*温度*/\n                    \"humidity\": \"54\",     /*湿度*/\n                    \"info\": \"雾\",\n                    \"img\": \"18\"\n                },\n                \"wind\": {\n                    \"direct\": \"北风\",\n                    \"power\": \"1级\",\n                    \"offset\": null,\n                    \"windspeed\": null\n                }\n            },\n            \"life\": {     /*生活指数*/\n                \"date\": \"2014-10-15\",\n                \"info\": {\n                    \"chuanyi\": [     /*穿衣指数*/\n                        \"较舒适\",\n                        \"建议着薄外套或牛仔衫裤等服装。年老体弱者宜着夹克衫、薄毛衣等。昼夜温差较大，注意适当增减衣服。\"\n                    ],\n                    \"ganmao\": [    /*感冒指数*/\n                        \"较易发\",\n                        \"昼夜温差较大，较易发生感冒，请适当增减衣服。体质较弱的朋友请注意防护。\"\n                    ],\n                    \"kongtiao\": [   /*空调指数*/\n                        \"较少开启\",\n                        \"您将感到很舒适，一般不需要开启空调。\"\n                    ],\n                    \"wuran\": [     /*污染指数*/\n                        \"良\",\n                        \"气象条件有利于空气污染物稀释、扩散和清除，可在室外正常活动。\"\n                    ],\n                    \"xiche\": [     /*洗车指数*/\n                        \"较适宜\",\n                        \"较适宜洗车，未来一天无雨，风力较小，擦洗一新的汽车至少能保持一天。\"\n                    ],\n                    \"yundong\": [     /*运动指数*/\n                        \"较适宜\",\n                        \"天气较好，但风力较大，推荐您进行室内运动，若在户外运动请注意防风。\"\n                    ],\n                    \"ziwaixian\": [   /*紫外线*/\n                        \"中等\",\n                        \"属中等强度紫外线辐射天气，外出时建议涂擦SPF高于15、PA+的防晒护肤品，戴帽子、太阳镜。\"\n                    ]\n                }\n            },\n         ............\n```\n上面是天气Api返回的json对象，之前开发中是用org.json工具进行解析的，可能我对那个工具也没有参悟得很透彻，我感觉我用的是最笨的方法，下面给出一小段之前写的解析代码：\n```java\n//取得result根\n JSONObject jsonresult = new JSONObject(value);\n String resultSTR = jsonresult.getString(\"result\");\n \n //取得DATA根\n JSONObject jsonDATA = new JSONObject(resultSTR);\n String dataSTR = jsonDATA.getString(\"data\");\n \n//取得realtime根\n JSONObject jsonRT = new JSONObject(dataSTR);\n String rtSTR = jsonRT.getString(\"realtime\");\nJSONObject jsonRealTime = new JSONObject(rtSTR);//这个是realtime的json对象\nString city = jsonRealTime.getString(\"city_name\"); //取得城市名称\n String updatetime = jsonRealTime.getString(\"date\") + \" \" + jsonRealTime.getString(\"time\");//获得更新时间，即为返回的数据的日期加更新具体时间\n```\n好了！废话说了这么多，该谈谈Gson了，回到那个问题，Gson是什么？\n其实也就是一个工具。\n\n---\n\n## 使用Gson前准备工作\n要使用它，我们要先下载它的依赖包，可以直接去github开源项目地址下载：https://github.com/google/gson\n我也搬运过来了，直接去下载也可以：http://download.csdn.net/detail/kevinwu93/9422464\n\n下载后，我们需要在工程项目中依赖它这个jar包，以Android Studio为例，可以放到module中的libs目录下，如下图所示：\n![这里写图片描述](http://img.blog.csdn.net/20160130141817334)\n接下来还需要在gradle文件中添加依赖语句\n```\ncompile files('libs/gson-2.5.jar')\n```\n\n这样，我们就导入这个工具了，接下来就可以使用了。\n\n---\n\n## 正式使用Gson\n这里主要讨论使用Gson的fromJson()方法解析Json字符串，获取相应的数据，至于toJson()方法，以后应该还会写篇文章。\n\n先来看看fromJson()这个方法：\nfromJson()这个方法的用法如下：\n```java\nnew Gson().fromJson(Json_string,class)\n```\n\n参数需要json字符串和一个实体，所以下面先来针对以上天气的返回数据创建一个实体：\n```java\npublic class WeatherEntity {\n    public String reason;\n    public ResultEntity result;\n    public int error_code;//错误码\n}\n```\n\n在这个天气实体中我分成了三部分，第一部分为一个字符串，对应返回的json数据的reason字段：\n```\n\"reason\": \"查询成功\"\n```\n\n最后的error_code对应json数据中的error_code字段：\n```\n\"error_code\": 0\n```\n\n下面说一下中中间的public ResultEntity result;这个实体类型\n因为返回的result字段的数据比较复杂，所以继续细分出来，先看看ResultEntityEntity这个类的代码：\n```java\npublic class ResultEntity {\n    public DataEntity data;\n}\n```\n\n因为result中又包含了一个data字段，所有我再分了一层，再来看看DataEntity部分的代码\n``` java\npublic class DataEntity {\n    public RealtimeEntity realtime;\n    public LifeEntity life;\n    public ArrayList<AdayWeatherEntity> weather=new ArrayList<AdayWeatherEntity>();\n    public Pm25Entity pm25;\n    public int date;\n    public int isForeign;\n}\n```\n\n分析这段代码前，先看一下返回的json的数据的结构（建议参照完整json数据返回内容）：\n```\n          \"realtime\": {\n                \"city_code\": \"101210701\",\n                \"city_name\": \"温州\",     /*城市*/\n                \"date\": \"2014-10-15\",  /*日期*/\n                \"time\": \"09:00:00\",     /*更新时间*/\n                 ............................省略\n            },\n            \"life\": {     /*生活指数*/\n                \"date\": \"2014-10-15\",\n                \"info\": {\n                    \"chuanyi\": [     /*穿衣指数*/\n                        \"较舒适\",\n                        \"建议着薄外套或牛仔衫裤等服装。年老体弱者宜着夹克衫、薄毛衣等。昼夜温差较大，注意适当增减衣服。\"\n                    ],\n                   ............................省略\n            },\n            \"weather\": [   /*未来几天天气预报*/\n                {\n                    \"date\": \"2014-10-15\",\n                    \"info\": {\n                        \"day\": [     /*白天天气*/\n               ............................省略\n            ],\n            \"pm25\": {    /*PM2.5*/\n                \"key\": \"Wenzhou\",\n                \"show_desc\": 0,\n                \"pm25\": {\n                    \"curPm\": \"97\",\n                    \"pm25\": \"72\",\n                    \"pm10\": \"97\",\n                    \"level\": 2,\n                    \"quality\": \"良\",\n                    \"des\": \"可以接受的，除极少数对某种污染物特别敏感的人以外，对公众健康没有危害。\"\n                },\n                \"dateTime\": \"2014年10月15日09时\",\n                \"cityName\": \"温州\"\n            },\n            \"date\": null,\n            \"isForeign\": 0\n```\n\n可以看到这里有几大字段，分别为：\n- realtime\n- life\n- weather\n- pm25\n- date\n- isForeign\n\n对于date和isForeign这两个字段来说，单一数据，可以直接用对应的数据类型做实体，解析很简单。\n对应realtime等类型的数据，结构相对来说还是比较复杂的，这里再单独出来进行解析，就用realtime做例子，其它的有需要可以参考github上项目的完整代码，这里不详细说明。\n先来看看RealtimeEntity这个类：\n``` java\npublic class RealtimeEntity {\n    public String city_code;//城市代码\n    public String city_name;//城市名称\n    public String date;//日期\n    public String time;//更新时间\n    public int week;//星期\n    public String moon;//农历、\n    public long dataUptime;//更新时间戳\n    public RealTimeWeatherEntity weather;//实时天气实体\n    public RealtimeWindEntity wind;//风速风力信息实体\n}\n```\n\n对于单一数据没嵌套的直接解析，对于还有嵌套的，继续细分，接下来看看RealTimeWeatherEntity和RealtimeWindEntity这两个类：\n```java\npublic class RealTimeWeatherEntity {\n    public String tempertrue;//实时温度\n    public String humidity;//湿度\n    public String info;//天气信息\n    public String img;//天气对应图片\n}\n```\n\n```java\npublic class RealtimeWindEntity {\n    public String direct;//风向\n    public String power;//风力\n    public String offset;//风向偏移量\n    public String windspeed;//风速\n}\n```\n这两个类都只是对数据进行定义，相当于把json中的数据一一对应地描述出来，这样进行了多层细分后，realtime这个字段返回的数据就每个都有了对应的变量来描述，其他的也同样道理，在对所有的数据进行实体定义后，就可以调用Gson方法进行解析了，解析部分的代码如下（我把测试的json数据放在个txt文件里面了）：\n```java\n/**\n    *测试gson实体\n    *@author KevinWu\n    *create at 2016/1/29 22:15\n    */\n    @Test\n    public void testEntity(){\n        String jsonStr=importStr();//导入要测试的数据\n        System.out.println(jsonStr);\n        Gson gson=new Gson();\n        WeatherEntity w=gson.fromJson(jsonStr,WeatherEntity.class);\n        System.out.println(w.result.data.pm25.pm25.pm10);\n    }\n \n    private String importStr(){\n        String str=\"\";\n        File myFile=new File(\"./json_test.txt\");\n        try {\n            FileReader myFileReader=new FileReader(myFile);\n            BufferedReader myBufferedReader=new BufferedReader(myFileReader);\n            String temp;\n            while((temp=myBufferedReader.readLine())!=null){\n                str=str+temp;\n            }\n            myBufferedReader.close();\n            myFileReader.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n```\n\n就这样。\n\nGithub项目地址：https://github.com/KevinWu1993/YTWeatherPro\n\n\n\n","slug":"Android/201601/Gson学习笔记","published":1,"updated":"2016-03-20T02:52:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinisi4k400043ntfo5yt6v0x","content":"<h2 id=\"Gson是什么\"><a href=\"#Gson是什么\" class=\"headerlink\" title=\"Gson是什么\"></a>Gson是什么</h2><p>要了解Gson是什么，恐怕得先说一下Json这个东西<br>（Json的背景知识就直接引用网络上的了<a href=\"http://www.open-open.com/lib/view/open1407376535942.html）。\" target=\"_blank\" rel=\"external\">http://www.open-open.com/lib/view/open1407376535942.html）。</a></p>\n<h3 id=\"什么是Json\"><a href=\"#什么是Json\" class=\"headerlink\" title=\"什么是Json\"></a>什么是Json</h3><p>JSON即JavaScript Object Natation, 它是一种轻量级的数据交换格式, 与XML一样, 是广泛被采用的客户端和服务端交互的解决方案.<br><a id=\"more\"></a></p>\n<h3 id=\"Json对象\"><a href=\"#Json对象\" class=\"headerlink\" title=\"Json对象\"></a>Json对象</h3><p>JSON中对象(Object)以”{“开始, 以”}”结束. 对象中的每一个item都是一个key-value对, 表现为”key:value”的形式, key-value对之间使用逗号分隔. 如:{“name”:”coolxing”, “age”=24, “male”:true, “address”:{“street”:”huiLongGuan”, “city”:”beijing”, “country”:”china”}}. JSON对象的key只能是string类型的, 而value可以是string, number, false, true, null, Object对象甚至是array数组, 也就是说可以存在嵌套的情况.</p>\n<h3 id=\"Json数组\"><a href=\"#Json数组\" class=\"headerlink\" title=\"Json数组\"></a>Json数组</h3><p>JSON数组(array)以”[“开始, 以”]”结束, 数组中的每一个元素可以是string, number, false, true, null, Object对象甚至是array数组, 数组间的元素使用逗号分隔. 如[“coolxing”, 24, {“street”:”huiLongGuan”, “city”:”beijing”, “country”:”china”}].</p>\n<p>好了Json的基本背景介绍完了，先看看一个天气Api返回的Json对象吧（截取部分）。<br>完整的json返回数据示例地址：<a href=\"https://github.com/KevinWu1993/YTWeatherPro/blob/dev/doc/%E5%AE%8C%E6%95%B4json%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE.md\" target=\"_blank\" rel=\"external\">https://github.com/KevinWu1993/YTWeatherPro/blob/dev/doc/%E5%AE%8C%E6%95%B4json%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE.md</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;reason&quot;: &quot;查询成功&quot;,</span><br><span class=\"line\">    &quot;result&quot;: &#123;</span><br><span class=\"line\">        &quot;data&quot;: &#123;</span><br><span class=\"line\">            &quot;realtime&quot;: &#123;</span><br><span class=\"line\">                &quot;city_code&quot;: &quot;101210701&quot;,</span><br><span class=\"line\">                &quot;city_name&quot;: &quot;温州&quot;,     /*城市*/</span><br><span class=\"line\">                &quot;date&quot;: &quot;2014-10-15&quot;,  /*日期*/</span><br><span class=\"line\">                &quot;time&quot;: &quot;09:00:00&quot;,     /*更新时间*/</span><br><span class=\"line\">                &quot;week&quot;: 3,</span><br><span class=\"line\">                &quot;moon&quot;: &quot;九月廿二&quot;,</span><br><span class=\"line\">                &quot;dataUptime&quot;: 1413337811,</span><br><span class=\"line\">                &quot;weather&quot;: &#123;    /*当前实况天气*/</span><br><span class=\"line\">                    &quot;temperature&quot;: &quot;19&quot;,     /*温度*/</span><br><span class=\"line\">                    &quot;humidity&quot;: &quot;54&quot;,     /*湿度*/</span><br><span class=\"line\">                    &quot;info&quot;: &quot;雾&quot;,</span><br><span class=\"line\">                    &quot;img&quot;: &quot;18&quot;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &quot;wind&quot;: &#123;</span><br><span class=\"line\">                    &quot;direct&quot;: &quot;北风&quot;,</span><br><span class=\"line\">                    &quot;power&quot;: &quot;1级&quot;,</span><br><span class=\"line\">                    &quot;offset&quot;: null,</span><br><span class=\"line\">                    &quot;windspeed&quot;: null</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &quot;life&quot;: &#123;     /*生活指数*/</span><br><span class=\"line\">                &quot;date&quot;: &quot;2014-10-15&quot;,</span><br><span class=\"line\">                &quot;info&quot;: &#123;</span><br><span class=\"line\">                    &quot;chuanyi&quot;: [     /*穿衣指数*/</span><br><span class=\"line\">                        &quot;较舒适&quot;,</span><br><span class=\"line\">                        &quot;建议着薄外套或牛仔衫裤等服装。年老体弱者宜着夹克衫、薄毛衣等。昼夜温差较大，注意适当增减衣服。&quot;</span><br><span class=\"line\">                    ],</span><br><span class=\"line\">                    &quot;ganmao&quot;: [    /*感冒指数*/</span><br><span class=\"line\">                        &quot;较易发&quot;,</span><br><span class=\"line\">                        &quot;昼夜温差较大，较易发生感冒，请适当增减衣服。体质较弱的朋友请注意防护。&quot;</span><br><span class=\"line\">                    ],</span><br><span class=\"line\">                    &quot;kongtiao&quot;: [   /*空调指数*/</span><br><span class=\"line\">                        &quot;较少开启&quot;,</span><br><span class=\"line\">                        &quot;您将感到很舒适，一般不需要开启空调。&quot;</span><br><span class=\"line\">                    ],</span><br><span class=\"line\">                    &quot;wuran&quot;: [     /*污染指数*/</span><br><span class=\"line\">                        &quot;良&quot;,</span><br><span class=\"line\">                        &quot;气象条件有利于空气污染物稀释、扩散和清除，可在室外正常活动。&quot;</span><br><span class=\"line\">                    ],</span><br><span class=\"line\">                    &quot;xiche&quot;: [     /*洗车指数*/</span><br><span class=\"line\">                        &quot;较适宜&quot;,</span><br><span class=\"line\">                        &quot;较适宜洗车，未来一天无雨，风力较小，擦洗一新的汽车至少能保持一天。&quot;</span><br><span class=\"line\">                    ],</span><br><span class=\"line\">                    &quot;yundong&quot;: [     /*运动指数*/</span><br><span class=\"line\">                        &quot;较适宜&quot;,</span><br><span class=\"line\">                        &quot;天气较好，但风力较大，推荐您进行室内运动，若在户外运动请注意防风。&quot;</span><br><span class=\"line\">                    ],</span><br><span class=\"line\">                    &quot;ziwaixian&quot;: [   /*紫外线*/</span><br><span class=\"line\">                        &quot;中等&quot;,</span><br><span class=\"line\">                        &quot;属中等强度紫外线辐射天气，外出时建议涂擦SPF高于15、PA+的防晒护肤品，戴帽子、太阳镜。&quot;</span><br><span class=\"line\">                    ]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">         ............</span><br></pre></td></tr></table></figure>\n<p>上面是天气Api返回的json对象，之前开发中是用org.json工具进行解析的，可能我对那个工具也没有参悟得很透彻，我感觉我用的是最笨的方法，下面给出一小段之前写的解析代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//取得result根</span></span><br><span class=\"line\"> JSONObject jsonresult = <span class=\"keyword\">new</span> JSONObject(value);</span><br><span class=\"line\"> String resultSTR = jsonresult.getString(<span class=\"string\">\"result\"</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">//取得DATA根</span></span><br><span class=\"line\"> JSONObject jsonDATA = <span class=\"keyword\">new</span> JSONObject(resultSTR);</span><br><span class=\"line\"> String dataSTR = jsonDATA.getString(<span class=\"string\">\"data\"</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//取得realtime根</span></span><br><span class=\"line\"> JSONObject jsonRT = <span class=\"keyword\">new</span> JSONObject(dataSTR);</span><br><span class=\"line\"> String rtSTR = jsonRT.getString(<span class=\"string\">\"realtime\"</span>);</span><br><span class=\"line\">JSONObject jsonRealTime = <span class=\"keyword\">new</span> JSONObject(rtSTR);<span class=\"comment\">//这个是realtime的json对象</span></span><br><span class=\"line\">String city = jsonRealTime.getString(<span class=\"string\">\"city_name\"</span>); <span class=\"comment\">//取得城市名称</span></span><br><span class=\"line\"> String updatetime = jsonRealTime.getString(<span class=\"string\">\"date\"</span>) + <span class=\"string\">\" \"</span> + jsonRealTime.getString(<span class=\"string\">\"time\"</span>);<span class=\"comment\">//获得更新时间，即为返回的数据的日期加更新具体时间</span></span><br></pre></td></tr></table></figure></p>\n<p>好了！废话说了这么多，该谈谈Gson了，回到那个问题，Gson是什么？<br>其实也就是一个工具。</p>\n<hr>\n<h2 id=\"使用Gson前准备工作\"><a href=\"#使用Gson前准备工作\" class=\"headerlink\" title=\"使用Gson前准备工作\"></a>使用Gson前准备工作</h2><p>要使用它，我们要先下载它的依赖包，可以直接去github开源项目地址下载：<a href=\"https://github.com/google/gson\" target=\"_blank\" rel=\"external\">https://github.com/google/gson</a><br>我也搬运过来了，直接去下载也可以：<a href=\"http://download.csdn.net/detail/kevinwu93/9422464\" target=\"_blank\" rel=\"external\">http://download.csdn.net/detail/kevinwu93/9422464</a></p>\n<p>下载后，我们需要在工程项目中依赖它这个jar包，以Android Studio为例，可以放到module中的libs目录下，如下图所示：<br><img src=\"http://img.blog.csdn.net/20160130141817334\" alt=\"这里写图片描述\"><br>接下来还需要在gradle文件中添加依赖语句<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile files(&apos;libs/gson-2.5.jar&apos;)</span><br></pre></td></tr></table></figure></p>\n<p>这样，我们就导入这个工具了，接下来就可以使用了。</p>\n<hr>\n<h2 id=\"正式使用Gson\"><a href=\"#正式使用Gson\" class=\"headerlink\" title=\"正式使用Gson\"></a>正式使用Gson</h2><p>这里主要讨论使用Gson的fromJson()方法解析Json字符串，获取相应的数据，至于toJson()方法，以后应该还会写篇文章。</p>\n<p>先来看看fromJson()这个方法：<br>fromJson()这个方法的用法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Gson().fromJson(Json_string,<span class=\"class\"><span class=\"keyword\">class</span>)</span></span><br></pre></td></tr></table></figure></p>\n<p>参数需要json字符串和一个实体，所以下面先来针对以上天气的返回数据创建一个实体：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeatherEntity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String reason;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ResultEntity result;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> error_code;<span class=\"comment\">//错误码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个天气实体中我分成了三部分，第一部分为一个字符串，对应返回的json数据的reason字段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;reason&quot;: &quot;查询成功&quot;</span><br></pre></td></tr></table></figure></p>\n<p>最后的error_code对应json数据中的error_code字段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;error_code&quot;: 0</span><br></pre></td></tr></table></figure></p>\n<p>下面说一下中中间的public ResultEntity result;这个实体类型<br>因为返回的result字段的数据比较复杂，所以继续细分出来，先看看ResultEntityEntity这个类的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResultEntity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> DataEntity data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为result中又包含了一个data字段，所有我再分了一层，再来看看DataEntity部分的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataEntity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> RealtimeEntity realtime;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> LifeEntity life;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ArrayList&lt;AdayWeatherEntity&gt; weather=<span class=\"keyword\">new</span> ArrayList&lt;AdayWeatherEntity&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Pm25Entity pm25;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> date;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> isForeign;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>分析这段代码前，先看一下返回的json的数据的结构（建议参照完整json数据返回内容）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;realtime&quot;: &#123;</span><br><span class=\"line\">      &quot;city_code&quot;: &quot;101210701&quot;,</span><br><span class=\"line\">      &quot;city_name&quot;: &quot;温州&quot;,     /*城市*/</span><br><span class=\"line\">      &quot;date&quot;: &quot;2014-10-15&quot;,  /*日期*/</span><br><span class=\"line\">      &quot;time&quot;: &quot;09:00:00&quot;,     /*更新时间*/</span><br><span class=\"line\">       ............................省略</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;life&quot;: &#123;     /*生活指数*/</span><br><span class=\"line\">      &quot;date&quot;: &quot;2014-10-15&quot;,</span><br><span class=\"line\">      &quot;info&quot;: &#123;</span><br><span class=\"line\">          &quot;chuanyi&quot;: [     /*穿衣指数*/</span><br><span class=\"line\">              &quot;较舒适&quot;,</span><br><span class=\"line\">              &quot;建议着薄外套或牛仔衫裤等服装。年老体弱者宜着夹克衫、薄毛衣等。昼夜温差较大，注意适当增减衣服。&quot;</span><br><span class=\"line\">          ],</span><br><span class=\"line\">         ............................省略</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;weather&quot;: [   /*未来几天天气预报*/</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          &quot;date&quot;: &quot;2014-10-15&quot;,</span><br><span class=\"line\">          &quot;info&quot;: &#123;</span><br><span class=\"line\">              &quot;day&quot;: [     /*白天天气*/</span><br><span class=\"line\">     ............................省略</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;pm25&quot;: &#123;    /*PM2.5*/</span><br><span class=\"line\">      &quot;key&quot;: &quot;Wenzhou&quot;,</span><br><span class=\"line\">      &quot;show_desc&quot;: 0,</span><br><span class=\"line\">      &quot;pm25&quot;: &#123;</span><br><span class=\"line\">          &quot;curPm&quot;: &quot;97&quot;,</span><br><span class=\"line\">          &quot;pm25&quot;: &quot;72&quot;,</span><br><span class=\"line\">          &quot;pm10&quot;: &quot;97&quot;,</span><br><span class=\"line\">          &quot;level&quot;: 2,</span><br><span class=\"line\">          &quot;quality&quot;: &quot;良&quot;,</span><br><span class=\"line\">          &quot;des&quot;: &quot;可以接受的，除极少数对某种污染物特别敏感的人以外，对公众健康没有危害。&quot;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &quot;dateTime&quot;: &quot;2014年10月15日09时&quot;,</span><br><span class=\"line\">      &quot;cityName&quot;: &quot;温州&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;date&quot;: null,</span><br><span class=\"line\">  &quot;isForeign&quot;: 0</span><br></pre></td></tr></table></figure></p>\n<p>可以看到这里有几大字段，分别为：</p>\n<ul>\n<li>realtime</li>\n<li>life</li>\n<li>weather</li>\n<li>pm25</li>\n<li>date</li>\n<li>isForeign</li>\n</ul>\n<p>对于date和isForeign这两个字段来说，单一数据，可以直接用对应的数据类型做实体，解析很简单。<br>对应realtime等类型的数据，结构相对来说还是比较复杂的，这里再单独出来进行解析，就用realtime做例子，其它的有需要可以参考github上项目的完整代码，这里不详细说明。<br>先来看看RealtimeEntity这个类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealtimeEntity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String city_code;<span class=\"comment\">//城市代码</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String city_name;<span class=\"comment\">//城市名称</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String date;<span class=\"comment\">//日期</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String time;<span class=\"comment\">//更新时间</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> week;<span class=\"comment\">//星期</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String moon;<span class=\"comment\">//农历、</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">long</span> dataUptime;<span class=\"comment\">//更新时间戳</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RealTimeWeatherEntity weather;<span class=\"comment\">//实时天气实体</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RealtimeWindEntity wind;<span class=\"comment\">//风速风力信息实体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对于单一数据没嵌套的直接解析，对于还有嵌套的，继续细分，接下来看看RealTimeWeatherEntity和RealtimeWindEntity这两个类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealTimeWeatherEntity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String tempertrue;<span class=\"comment\">//实时温度</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String humidity;<span class=\"comment\">//湿度</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String info;<span class=\"comment\">//天气信息</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String img;<span class=\"comment\">//天气对应图片</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealtimeWindEntity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String direct;<span class=\"comment\">//风向</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String power;<span class=\"comment\">//风力</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String offset;<span class=\"comment\">//风向偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String windspeed;<span class=\"comment\">//风速</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这两个类都只是对数据进行定义，相当于把json中的数据一一对应地描述出来，这样进行了多层细分后，realtime这个字段返回的数据就每个都有了对应的变量来描述，其他的也同样道理，在对所有的数据进行实体定义后，就可以调用Gson方法进行解析了，解析部分的代码如下（我把测试的json数据放在个txt文件里面了）：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span><br><span class=\"line\">    *测试gson实体</span><br><span class=\"line\">    *<span class=\"doctag\">@author</span> KevinWu</span><br><span class=\"line\">    *create at 2016/1/29 22:15</span><br><span class=\"line\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testEntity</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        String jsonStr=importStr();<span class=\"comment\">//导入要测试的数据</span></span><br><span class=\"line\">        System.out.println(jsonStr);</span><br><span class=\"line\">        Gson gson=<span class=\"keyword\">new</span> Gson();</span><br><span class=\"line\">        WeatherEntity w=gson.fromJson(jsonStr,WeatherEntity.class);</span><br><span class=\"line\">        System.out.println(w.result.data.pm25.pm25.pm10);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">importStr</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        String str=<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        File myFile=<span class=\"keyword\">new</span> File(<span class=\"string\">\"./json_test.txt\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            FileReader myFileReader=<span class=\"keyword\">new</span> FileReader(myFile);</span><br><span class=\"line\">            BufferedReader myBufferedReader=<span class=\"keyword\">new</span> BufferedReader(myFileReader);</span><br><span class=\"line\">            String temp;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>((temp=myBufferedReader.readLine())!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                str=str+temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            myBufferedReader.close();</span><br><span class=\"line\">            myFileReader.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>就这样。</p>\n<p>Github项目地址：<a href=\"https://github.com/KevinWu1993/YTWeatherPro\" target=\"_blank\" rel=\"external\">https://github.com/KevinWu1993/YTWeatherPro</a></p>\n","excerpt":"<h2 id=\"Gson是什么\"><a href=\"#Gson是什么\" class=\"headerlink\" title=\"Gson是什么\"></a>Gson是什么</h2><p>要了解Gson是什么，恐怕得先说一下Json这个东西<br>（Json的背景知识就直接引用网络上的了<a href=\"http://www.open-open.com/lib/view/open1407376535942.html）。\">http://www.open-open.com/lib/view/open1407376535942.html）。</a></p>\n<h3 id=\"什么是Json\"><a href=\"#什么是Json\" class=\"headerlink\" title=\"什么是Json\"></a>什么是Json</h3><p>JSON即JavaScript Object Natation, 它是一种轻量级的数据交换格式, 与XML一样, 是广泛被采用的客户端和服务端交互的解决方案.<br>","more":"</p>\n<h3 id=\"Json对象\"><a href=\"#Json对象\" class=\"headerlink\" title=\"Json对象\"></a>Json对象</h3><p>JSON中对象(Object)以”{“开始, 以”}”结束. 对象中的每一个item都是一个key-value对, 表现为”key:value”的形式, key-value对之间使用逗号分隔. 如:{“name”:”coolxing”, “age”=24, “male”:true, “address”:{“street”:”huiLongGuan”, “city”:”beijing”, “country”:”china”}}. JSON对象的key只能是string类型的, 而value可以是string, number, false, true, null, Object对象甚至是array数组, 也就是说可以存在嵌套的情况.</p>\n<h3 id=\"Json数组\"><a href=\"#Json数组\" class=\"headerlink\" title=\"Json数组\"></a>Json数组</h3><p>JSON数组(array)以”[“开始, 以”]”结束, 数组中的每一个元素可以是string, number, false, true, null, Object对象甚至是array数组, 数组间的元素使用逗号分隔. 如[“coolxing”, 24, {“street”:”huiLongGuan”, “city”:”beijing”, “country”:”china”}].</p>\n<p>好了Json的基本背景介绍完了，先看看一个天气Api返回的Json对象吧（截取部分）。<br>完整的json返回数据示例地址：<a href=\"https://github.com/KevinWu1993/YTWeatherPro/blob/dev/doc/%E5%AE%8C%E6%95%B4json%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE.md\">https://github.com/KevinWu1993/YTWeatherPro/blob/dev/doc/%E5%AE%8C%E6%95%B4json%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE.md</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;reason&quot;: &quot;查询成功&quot;,</span><br><span class=\"line\">    &quot;result&quot;: &#123;</span><br><span class=\"line\">        &quot;data&quot;: &#123;</span><br><span class=\"line\">            &quot;realtime&quot;: &#123;</span><br><span class=\"line\">                &quot;city_code&quot;: &quot;101210701&quot;,</span><br><span class=\"line\">                &quot;city_name&quot;: &quot;温州&quot;,     /*城市*/</span><br><span class=\"line\">                &quot;date&quot;: &quot;2014-10-15&quot;,  /*日期*/</span><br><span class=\"line\">                &quot;time&quot;: &quot;09:00:00&quot;,     /*更新时间*/</span><br><span class=\"line\">                &quot;week&quot;: 3,</span><br><span class=\"line\">                &quot;moon&quot;: &quot;九月廿二&quot;,</span><br><span class=\"line\">                &quot;dataUptime&quot;: 1413337811,</span><br><span class=\"line\">                &quot;weather&quot;: &#123;    /*当前实况天气*/</span><br><span class=\"line\">                    &quot;temperature&quot;: &quot;19&quot;,     /*温度*/</span><br><span class=\"line\">                    &quot;humidity&quot;: &quot;54&quot;,     /*湿度*/</span><br><span class=\"line\">                    &quot;info&quot;: &quot;雾&quot;,</span><br><span class=\"line\">                    &quot;img&quot;: &quot;18&quot;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &quot;wind&quot;: &#123;</span><br><span class=\"line\">                    &quot;direct&quot;: &quot;北风&quot;,</span><br><span class=\"line\">                    &quot;power&quot;: &quot;1级&quot;,</span><br><span class=\"line\">                    &quot;offset&quot;: null,</span><br><span class=\"line\">                    &quot;windspeed&quot;: null</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &quot;life&quot;: &#123;     /*生活指数*/</span><br><span class=\"line\">                &quot;date&quot;: &quot;2014-10-15&quot;,</span><br><span class=\"line\">                &quot;info&quot;: &#123;</span><br><span class=\"line\">                    &quot;chuanyi&quot;: [     /*穿衣指数*/</span><br><span class=\"line\">                        &quot;较舒适&quot;,</span><br><span class=\"line\">                        &quot;建议着薄外套或牛仔衫裤等服装。年老体弱者宜着夹克衫、薄毛衣等。昼夜温差较大，注意适当增减衣服。&quot;</span><br><span class=\"line\">                    ],</span><br><span class=\"line\">                    &quot;ganmao&quot;: [    /*感冒指数*/</span><br><span class=\"line\">                        &quot;较易发&quot;,</span><br><span class=\"line\">                        &quot;昼夜温差较大，较易发生感冒，请适当增减衣服。体质较弱的朋友请注意防护。&quot;</span><br><span class=\"line\">                    ],</span><br><span class=\"line\">                    &quot;kongtiao&quot;: [   /*空调指数*/</span><br><span class=\"line\">                        &quot;较少开启&quot;,</span><br><span class=\"line\">                        &quot;您将感到很舒适，一般不需要开启空调。&quot;</span><br><span class=\"line\">                    ],</span><br><span class=\"line\">                    &quot;wuran&quot;: [     /*污染指数*/</span><br><span class=\"line\">                        &quot;良&quot;,</span><br><span class=\"line\">                        &quot;气象条件有利于空气污染物稀释、扩散和清除，可在室外正常活动。&quot;</span><br><span class=\"line\">                    ],</span><br><span class=\"line\">                    &quot;xiche&quot;: [     /*洗车指数*/</span><br><span class=\"line\">                        &quot;较适宜&quot;,</span><br><span class=\"line\">                        &quot;较适宜洗车，未来一天无雨，风力较小，擦洗一新的汽车至少能保持一天。&quot;</span><br><span class=\"line\">                    ],</span><br><span class=\"line\">                    &quot;yundong&quot;: [     /*运动指数*/</span><br><span class=\"line\">                        &quot;较适宜&quot;,</span><br><span class=\"line\">                        &quot;天气较好，但风力较大，推荐您进行室内运动，若在户外运动请注意防风。&quot;</span><br><span class=\"line\">                    ],</span><br><span class=\"line\">                    &quot;ziwaixian&quot;: [   /*紫外线*/</span><br><span class=\"line\">                        &quot;中等&quot;,</span><br><span class=\"line\">                        &quot;属中等强度紫外线辐射天气，外出时建议涂擦SPF高于15、PA+的防晒护肤品，戴帽子、太阳镜。&quot;</span><br><span class=\"line\">                    ]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">         ............</span><br></pre></td></tr></table></figure>\n<p>上面是天气Api返回的json对象，之前开发中是用org.json工具进行解析的，可能我对那个工具也没有参悟得很透彻，我感觉我用的是最笨的方法，下面给出一小段之前写的解析代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//取得result根</span></span><br><span class=\"line\"> JSONObject jsonresult = <span class=\"keyword\">new</span> JSONObject(value);</span><br><span class=\"line\"> String resultSTR = jsonresult.getString(<span class=\"string\">\"result\"</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">//取得DATA根</span></span><br><span class=\"line\"> JSONObject jsonDATA = <span class=\"keyword\">new</span> JSONObject(resultSTR);</span><br><span class=\"line\"> String dataSTR = jsonDATA.getString(<span class=\"string\">\"data\"</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//取得realtime根</span></span><br><span class=\"line\"> JSONObject jsonRT = <span class=\"keyword\">new</span> JSONObject(dataSTR);</span><br><span class=\"line\"> String rtSTR = jsonRT.getString(<span class=\"string\">\"realtime\"</span>);</span><br><span class=\"line\">JSONObject jsonRealTime = <span class=\"keyword\">new</span> JSONObject(rtSTR);<span class=\"comment\">//这个是realtime的json对象</span></span><br><span class=\"line\">String city = jsonRealTime.getString(<span class=\"string\">\"city_name\"</span>); <span class=\"comment\">//取得城市名称</span></span><br><span class=\"line\"> String updatetime = jsonRealTime.getString(<span class=\"string\">\"date\"</span>) + <span class=\"string\">\" \"</span> + jsonRealTime.getString(<span class=\"string\">\"time\"</span>);<span class=\"comment\">//获得更新时间，即为返回的数据的日期加更新具体时间</span></span><br></pre></td></tr></table></figure></p>\n<p>好了！废话说了这么多，该谈谈Gson了，回到那个问题，Gson是什么？<br>其实也就是一个工具。</p>\n<hr>\n<h2 id=\"使用Gson前准备工作\"><a href=\"#使用Gson前准备工作\" class=\"headerlink\" title=\"使用Gson前准备工作\"></a>使用Gson前准备工作</h2><p>要使用它，我们要先下载它的依赖包，可以直接去github开源项目地址下载：<a href=\"https://github.com/google/gson\">https://github.com/google/gson</a><br>我也搬运过来了，直接去下载也可以：<a href=\"http://download.csdn.net/detail/kevinwu93/9422464\">http://download.csdn.net/detail/kevinwu93/9422464</a></p>\n<p>下载后，我们需要在工程项目中依赖它这个jar包，以Android Studio为例，可以放到module中的libs目录下，如下图所示：<br><img src=\"http://img.blog.csdn.net/20160130141817334\" alt=\"这里写图片描述\"><br>接下来还需要在gradle文件中添加依赖语句<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile files(&apos;libs/gson-2.5.jar&apos;)</span><br></pre></td></tr></table></figure></p>\n<p>这样，我们就导入这个工具了，接下来就可以使用了。</p>\n<hr>\n<h2 id=\"正式使用Gson\"><a href=\"#正式使用Gson\" class=\"headerlink\" title=\"正式使用Gson\"></a>正式使用Gson</h2><p>这里主要讨论使用Gson的fromJson()方法解析Json字符串，获取相应的数据，至于toJson()方法，以后应该还会写篇文章。</p>\n<p>先来看看fromJson()这个方法：<br>fromJson()这个方法的用法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Gson().fromJson(Json_string,<span class=\"class\"><span class=\"keyword\">class</span>)</span></span><br></pre></td></tr></table></figure></p>\n<p>参数需要json字符串和一个实体，所以下面先来针对以上天气的返回数据创建一个实体：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WeatherEntity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String reason;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ResultEntity result;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> error_code;<span class=\"comment\">//错误码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个天气实体中我分成了三部分，第一部分为一个字符串，对应返回的json数据的reason字段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;reason&quot;: &quot;查询成功&quot;</span><br></pre></td></tr></table></figure></p>\n<p>最后的error_code对应json数据中的error_code字段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;error_code&quot;: 0</span><br></pre></td></tr></table></figure></p>\n<p>下面说一下中中间的public ResultEntity result;这个实体类型<br>因为返回的result字段的数据比较复杂，所以继续细分出来，先看看ResultEntityEntity这个类的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResultEntity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> DataEntity data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为result中又包含了一个data字段，所有我再分了一层，再来看看DataEntity部分的代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataEntity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> RealtimeEntity realtime;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> LifeEntity life;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ArrayList&lt;AdayWeatherEntity&gt; weather=<span class=\"keyword\">new</span> ArrayList&lt;AdayWeatherEntity&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Pm25Entity pm25;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> date;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> isForeign;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>分析这段代码前，先看一下返回的json的数据的结构（建议参照完整json数据返回内容）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;realtime&quot;: &#123;</span><br><span class=\"line\">      &quot;city_code&quot;: &quot;101210701&quot;,</span><br><span class=\"line\">      &quot;city_name&quot;: &quot;温州&quot;,     /*城市*/</span><br><span class=\"line\">      &quot;date&quot;: &quot;2014-10-15&quot;,  /*日期*/</span><br><span class=\"line\">      &quot;time&quot;: &quot;09:00:00&quot;,     /*更新时间*/</span><br><span class=\"line\">       ............................省略</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;life&quot;: &#123;     /*生活指数*/</span><br><span class=\"line\">      &quot;date&quot;: &quot;2014-10-15&quot;,</span><br><span class=\"line\">      &quot;info&quot;: &#123;</span><br><span class=\"line\">          &quot;chuanyi&quot;: [     /*穿衣指数*/</span><br><span class=\"line\">              &quot;较舒适&quot;,</span><br><span class=\"line\">              &quot;建议着薄外套或牛仔衫裤等服装。年老体弱者宜着夹克衫、薄毛衣等。昼夜温差较大，注意适当增减衣服。&quot;</span><br><span class=\"line\">          ],</span><br><span class=\"line\">         ............................省略</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;weather&quot;: [   /*未来几天天气预报*/</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          &quot;date&quot;: &quot;2014-10-15&quot;,</span><br><span class=\"line\">          &quot;info&quot;: &#123;</span><br><span class=\"line\">              &quot;day&quot;: [     /*白天天气*/</span><br><span class=\"line\">     ............................省略</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;pm25&quot;: &#123;    /*PM2.5*/</span><br><span class=\"line\">      &quot;key&quot;: &quot;Wenzhou&quot;,</span><br><span class=\"line\">      &quot;show_desc&quot;: 0,</span><br><span class=\"line\">      &quot;pm25&quot;: &#123;</span><br><span class=\"line\">          &quot;curPm&quot;: &quot;97&quot;,</span><br><span class=\"line\">          &quot;pm25&quot;: &quot;72&quot;,</span><br><span class=\"line\">          &quot;pm10&quot;: &quot;97&quot;,</span><br><span class=\"line\">          &quot;level&quot;: 2,</span><br><span class=\"line\">          &quot;quality&quot;: &quot;良&quot;,</span><br><span class=\"line\">          &quot;des&quot;: &quot;可以接受的，除极少数对某种污染物特别敏感的人以外，对公众健康没有危害。&quot;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &quot;dateTime&quot;: &quot;2014年10月15日09时&quot;,</span><br><span class=\"line\">      &quot;cityName&quot;: &quot;温州&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;date&quot;: null,</span><br><span class=\"line\">  &quot;isForeign&quot;: 0</span><br></pre></td></tr></table></figure></p>\n<p>可以看到这里有几大字段，分别为：</p>\n<ul>\n<li>realtime</li>\n<li>life</li>\n<li>weather</li>\n<li>pm25</li>\n<li>date</li>\n<li>isForeign</li>\n</ul>\n<p>对于date和isForeign这两个字段来说，单一数据，可以直接用对应的数据类型做实体，解析很简单。<br>对应realtime等类型的数据，结构相对来说还是比较复杂的，这里再单独出来进行解析，就用realtime做例子，其它的有需要可以参考github上项目的完整代码，这里不详细说明。<br>先来看看RealtimeEntity这个类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealtimeEntity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String city_code;<span class=\"comment\">//城市代码</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String city_name;<span class=\"comment\">//城市名称</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String date;<span class=\"comment\">//日期</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String time;<span class=\"comment\">//更新时间</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> week;<span class=\"comment\">//星期</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String moon;<span class=\"comment\">//农历、</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">long</span> dataUptime;<span class=\"comment\">//更新时间戳</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RealTimeWeatherEntity weather;<span class=\"comment\">//实时天气实体</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RealtimeWindEntity wind;<span class=\"comment\">//风速风力信息实体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对于单一数据没嵌套的直接解析，对于还有嵌套的，继续细分，接下来看看RealTimeWeatherEntity和RealtimeWindEntity这两个类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealTimeWeatherEntity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String tempertrue;<span class=\"comment\">//实时温度</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String humidity;<span class=\"comment\">//湿度</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String info;<span class=\"comment\">//天气信息</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String img;<span class=\"comment\">//天气对应图片</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealtimeWindEntity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String direct;<span class=\"comment\">//风向</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String power;<span class=\"comment\">//风力</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String offset;<span class=\"comment\">//风向偏移量</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String windspeed;<span class=\"comment\">//风速</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这两个类都只是对数据进行定义，相当于把json中的数据一一对应地描述出来，这样进行了多层细分后，realtime这个字段返回的数据就每个都有了对应的变量来描述，其他的也同样道理，在对所有的数据进行实体定义后，就可以调用Gson方法进行解析了，解析部分的代码如下（我把测试的json数据放在个txt文件里面了）：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span><br><span class=\"line\">    *测试gson实体</span><br><span class=\"line\">    *<span class=\"doctag\">@author</span> KevinWu</span><br><span class=\"line\">    *create at 2016/1/29 22:15</span><br><span class=\"line\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testEntity</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        String jsonStr=importStr();<span class=\"comment\">//导入要测试的数据</span></span><br><span class=\"line\">        System.out.println(jsonStr);</span><br><span class=\"line\">        Gson gson=<span class=\"keyword\">new</span> Gson();</span><br><span class=\"line\">        WeatherEntity w=gson.fromJson(jsonStr,WeatherEntity.class);</span><br><span class=\"line\">        System.out.println(w.result.data.pm25.pm25.pm10);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">importStr</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        String str=<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        File myFile=<span class=\"keyword\">new</span> File(<span class=\"string\">\"./json_test.txt\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            FileReader myFileReader=<span class=\"keyword\">new</span> FileReader(myFile);</span><br><span class=\"line\">            BufferedReader myBufferedReader=<span class=\"keyword\">new</span> BufferedReader(myFileReader);</span><br><span class=\"line\">            String temp;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>((temp=myBufferedReader.readLine())!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                str=str+temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            myBufferedReader.close();</span><br><span class=\"line\">            myFileReader.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>就这样。</p>\n<p>Github项目地址：<a href=\"https://github.com/KevinWu1993/YTWeatherPro\">https://github.com/KevinWu1993/YTWeatherPro</a></p>"},{"title":"Android四大组件之一——Activity","date":"2016-03-21T16:00:00.000Z","author":"KevinWu","_content":"> Activity是Android的四大组件之一，这里将梳理一下有关Activity的东西\n\n\n\n## Activity的四种状态\n\n**Active状态：**在这种状态的Activity，必须是在栈顶的，此时它是可视的，并且可以获取焦点和用户的输入，Android系统将会保证在这种状态的Activity有充分的资源，当资源不足时就会试图杀死其它Activity来提供足够的资源，当激活另一个Activity后，当前Active状态的Activity将会进入Paused状态。\n<!--more-->\n**Paused状态：**当一个透明或者非全屏的Activity被激活时，前一个处于Active状态的Activity将会进入Paused状态，处于这种状态的Activity依然处于活动状态，只是不再能获取焦点和用户输入，如果当前被激活的Activity的资源足够的情况下，Android不会主动杀死处于Paused状态的Activity，当一个Activity变得完全不可见时，它将会进入Stoped状态。\n\n**Stoped状态：**当一个Activity变得完全不可见，就代表它此时进入了Stoped状态。虽然此时该Activity被停止了，但内存中仍保存这这个Activity的所有信息，但当Android出现内存资源不足时，处于这种状态的Activity是最有可能被杀死的。当一个Activity退出或关闭了，就会进入Killed状态。\n\n**Killed状态：**当一个Activity被退出了或者关闭了，就进入了这种状态，处于这种状态的Activity，在需要时可以重新启用它。\n\n\n\n## Activity生命周期\n\n*了解一个组件，生命周期这个一定要了解，才能更好地把握在什么时候该做什么事。*\n\n说到生命周期，必然少不了这张图：\n\n\n\n#### 简单说明一下这张图：\n\n![](http://i12.tietuku.cn/2bf48e46914376f0.png)\n- 当一个Activity启动后，系统会先调用Activity中的onCreate()方法，这个方法也是见得最多的。\n\n- 执行完onCreate()方法后，系统会依次调用onStart()、onResume()方法，调用完这个方法后，一个Activity就算正式启动完成了，此时Activity显示在前台，也就是处于前面所说的四种状态中的Active状态。\n\n- 当另一个Activity被激活，并占据前台时，当前处于Active状态的Activity将执行onPause()状态，此时也就是前面所说的四种状态中的Paused状态。此时如果系统资源不足，需要资源，很可能处于这个状态的Activity将被杀死，就进入了Killed状态，又或者，处于这个状态的Activity又重新回到前台，那么将重新调用onResume()方法，Activity将重新进入前台显示。\n\n- 当一个Activity不再可见后，即执行该Activity的onStop()方法，执行该方法说明该Activity进入了前面四种状态中的Stoped状态，此时也跟Paused状态一样，有两种可能，只是这里在回到前台后，执行的不是onResume()方法，而是先执行onRestart()方法。然后执行onStart()方法，再执行onResume()方法。（我个人把这个理解为重新启动的过程，不知道这么理解有没有问题）\n\n- 当用户退出Activity后，如果处于任何状态的Activity都会按照图示顺序执行下来，执行onStop()方法后，就会执行onDestory()方法，执行完onDestory()方法后，这个Activity将被正式关闭了。\n\n\n\n#### 下面引用网上对这几种方法的介绍，来说明下这几种方法：\n\n- onCreate：当Activity第一次启动的时候，触发这个方法，可以在此时完成Activity的初始化工作。onCreate方法有一个参数，这个参数可以为空，也可以是之前调用onSaveInstanceState()方法保存的状态信息。\n\n- onStart：该方法的触发表示所属活动将被展现给用户。\n\n- onResume：当一个活动和用户发生交互时，就会触发该方法。\n\n- onPause：当一个正在前台运行的活动因为其他活动需要前台运行而转入后台运行的时候，触发该方法。这时候需要将活动的状态持久化，比如正在编辑的数据库记录等。\n\n- onStop：当一个活动不需要展示给用户的时候，就会触发该方法。如果内存紧张，系统会直接结束这个活动，而不会触发onStop方法。所以保存状态信息是应该在onPause时做，而不是onStop时候做。活动如果没有在前台运行，都将被停止或者Linux管理进程为了给新的活动预留足够的存储空间而随时结束这些活动，因此对于开发者来说，在设计应用程序的时候，必须时刻牢记这一原则。在一些情况下，onPause方法或许是活动触发的最后的方法，因此开发者需要在这个时候保存需要保存的信息。\n\n- onRestart：当处于停止状态的活动需要再次展现给用户的时候，触发该方法。\n\n- onDestory：当活动销毁的时候，触发该方法。和onStop方法一样，如果内存紧张，系统会直接结束这个活动而不会触发这个方法。\n\n\n\n另：\n\n**onSaveInstanceState：**系统调用该方法，允许活动保存之前的状态，比如说在一串字符串中的光标所处的位置等。\n\n通常情况下，开发者不需要重写覆盖该方法，在默认实现中，已经提供了自动保存活动所设计的用户界面组件的所有状态信息。\n\n\n\n## Activity的四种加载模式\n\nActivity提供了四种加载模式，分别为：standard、singleTop、singleTask、singleInstance模式。\n\n这四种模式都是在AndroidManifest.xml文件中通过android:lanchMode来指定的，在介绍这四种启动模式之前，有必要先来了解一个概念——**Activity栈**\n\n\n\n### Activity栈\n\nAndroid是通过栈来保存Activity的，栈底的元素就是整个任务的发起者。\n\n当一个应用启动时，如果当前没有该应用的任务栈，就会创建一个任务栈，有了任务栈后，这个应用所启动的Activity都将在这个任务栈中被管理。\n\n有一点需要注意的，一个任务栈中Activity可能来自不同应用，同一个应用的Activity也可能不再一个任务栈中。\n\n一般情况下，当一个任务栈中的一个Activity启动了另一个Activity的时候，新启动的Activity就会进入任务栈顶端，并处于Active状态，而启动它的Activity就被顶下去一个位置，处于Stoped状态（不可见的情况下），当当前Activity执行完后，即用户按下返回键或者调用了finish()方法后，当前Activity出栈，启动它的Activity就宠幸回到Active状态。\n\n这就是基于栈的后进先出的任务栈。\n\n### standard模式\n\n这是默认的加载模式，这种加载模式每次都会创建一个新的Activity，每创建一次，新的Activity就会覆盖在原有的Activity上。\n\n### singleTop模式\n\n我个人理解就相当与栈顶单实例模式，设置了这种模式的Activity，在启动时会先判断该Activity是否处于栈顶，如果处于栈顶就不会新建Activity实例，而是直接重新启动在栈顶的这个Activity，并调用onNewIntent()方法。\n\n### singleTask模式\n\nsingleTask模式和singleTop模式类似，不过与singleTop检测栈顶元素是否是需要启动的Activity不同的是，singleTask是检测整个Activity栈中是否存在需要启动的Activity，如果存在，就把该Activity顶到栈顶，在该Activity上的Activity都会出栈销毁。\n\n上面是对处于同一个应用中启动的singleTask模式的Activity的处理。\n\n对于在其他应用中启动singleTask模式的Activity，如果后台任务栈不存在要启动的Activity，那么将会创建一个新的任务栈，如果后台任务栈中存在要启动的Activity，该后台任务栈就会切换到前台。\n\n### singleInstance\n\nsingleInstance可以简单理解为singleTask的加强版，这个加载模式具备singleTask的所有特性，但在任务栈的处理上加强了，处于这种模式的Activity，每一个Activity都会单独处于一个任务栈中，而且那个任务栈中智能存在单个Activity。\n\n\n\n","source":"_posts/Android/201603/ Android四大组件之一——Activity.md","raw":"title: Android四大组件之一——Activity\ndate: 2016-03-22\nauthor:  KevinWu\ncategories: Android\ntags: \n\t- Java \n\t- Android\n        - 加载模式\n\t- Activity\n\t- 启动模式\n---\n> Activity是Android的四大组件之一，这里将梳理一下有关Activity的东西\n\n\n\n## Activity的四种状态\n\n**Active状态：**在这种状态的Activity，必须是在栈顶的，此时它是可视的，并且可以获取焦点和用户的输入，Android系统将会保证在这种状态的Activity有充分的资源，当资源不足时就会试图杀死其它Activity来提供足够的资源，当激活另一个Activity后，当前Active状态的Activity将会进入Paused状态。\n<!--more-->\n**Paused状态：**当一个透明或者非全屏的Activity被激活时，前一个处于Active状态的Activity将会进入Paused状态，处于这种状态的Activity依然处于活动状态，只是不再能获取焦点和用户输入，如果当前被激活的Activity的资源足够的情况下，Android不会主动杀死处于Paused状态的Activity，当一个Activity变得完全不可见时，它将会进入Stoped状态。\n\n**Stoped状态：**当一个Activity变得完全不可见，就代表它此时进入了Stoped状态。虽然此时该Activity被停止了，但内存中仍保存这这个Activity的所有信息，但当Android出现内存资源不足时，处于这种状态的Activity是最有可能被杀死的。当一个Activity退出或关闭了，就会进入Killed状态。\n\n**Killed状态：**当一个Activity被退出了或者关闭了，就进入了这种状态，处于这种状态的Activity，在需要时可以重新启用它。\n\n\n\n## Activity生命周期\n\n*了解一个组件，生命周期这个一定要了解，才能更好地把握在什么时候该做什么事。*\n\n说到生命周期，必然少不了这张图：\n\n\n\n#### 简单说明一下这张图：\n\n![](http://i12.tietuku.cn/2bf48e46914376f0.png)\n- 当一个Activity启动后，系统会先调用Activity中的onCreate()方法，这个方法也是见得最多的。\n\n- 执行完onCreate()方法后，系统会依次调用onStart()、onResume()方法，调用完这个方法后，一个Activity就算正式启动完成了，此时Activity显示在前台，也就是处于前面所说的四种状态中的Active状态。\n\n- 当另一个Activity被激活，并占据前台时，当前处于Active状态的Activity将执行onPause()状态，此时也就是前面所说的四种状态中的Paused状态。此时如果系统资源不足，需要资源，很可能处于这个状态的Activity将被杀死，就进入了Killed状态，又或者，处于这个状态的Activity又重新回到前台，那么将重新调用onResume()方法，Activity将重新进入前台显示。\n\n- 当一个Activity不再可见后，即执行该Activity的onStop()方法，执行该方法说明该Activity进入了前面四种状态中的Stoped状态，此时也跟Paused状态一样，有两种可能，只是这里在回到前台后，执行的不是onResume()方法，而是先执行onRestart()方法。然后执行onStart()方法，再执行onResume()方法。（我个人把这个理解为重新启动的过程，不知道这么理解有没有问题）\n\n- 当用户退出Activity后，如果处于任何状态的Activity都会按照图示顺序执行下来，执行onStop()方法后，就会执行onDestory()方法，执行完onDestory()方法后，这个Activity将被正式关闭了。\n\n\n\n#### 下面引用网上对这几种方法的介绍，来说明下这几种方法：\n\n- onCreate：当Activity第一次启动的时候，触发这个方法，可以在此时完成Activity的初始化工作。onCreate方法有一个参数，这个参数可以为空，也可以是之前调用onSaveInstanceState()方法保存的状态信息。\n\n- onStart：该方法的触发表示所属活动将被展现给用户。\n\n- onResume：当一个活动和用户发生交互时，就会触发该方法。\n\n- onPause：当一个正在前台运行的活动因为其他活动需要前台运行而转入后台运行的时候，触发该方法。这时候需要将活动的状态持久化，比如正在编辑的数据库记录等。\n\n- onStop：当一个活动不需要展示给用户的时候，就会触发该方法。如果内存紧张，系统会直接结束这个活动，而不会触发onStop方法。所以保存状态信息是应该在onPause时做，而不是onStop时候做。活动如果没有在前台运行，都将被停止或者Linux管理进程为了给新的活动预留足够的存储空间而随时结束这些活动，因此对于开发者来说，在设计应用程序的时候，必须时刻牢记这一原则。在一些情况下，onPause方法或许是活动触发的最后的方法，因此开发者需要在这个时候保存需要保存的信息。\n\n- onRestart：当处于停止状态的活动需要再次展现给用户的时候，触发该方法。\n\n- onDestory：当活动销毁的时候，触发该方法。和onStop方法一样，如果内存紧张，系统会直接结束这个活动而不会触发这个方法。\n\n\n\n另：\n\n**onSaveInstanceState：**系统调用该方法，允许活动保存之前的状态，比如说在一串字符串中的光标所处的位置等。\n\n通常情况下，开发者不需要重写覆盖该方法，在默认实现中，已经提供了自动保存活动所设计的用户界面组件的所有状态信息。\n\n\n\n## Activity的四种加载模式\n\nActivity提供了四种加载模式，分别为：standard、singleTop、singleTask、singleInstance模式。\n\n这四种模式都是在AndroidManifest.xml文件中通过android:lanchMode来指定的，在介绍这四种启动模式之前，有必要先来了解一个概念——**Activity栈**\n\n\n\n### Activity栈\n\nAndroid是通过栈来保存Activity的，栈底的元素就是整个任务的发起者。\n\n当一个应用启动时，如果当前没有该应用的任务栈，就会创建一个任务栈，有了任务栈后，这个应用所启动的Activity都将在这个任务栈中被管理。\n\n有一点需要注意的，一个任务栈中Activity可能来自不同应用，同一个应用的Activity也可能不再一个任务栈中。\n\n一般情况下，当一个任务栈中的一个Activity启动了另一个Activity的时候，新启动的Activity就会进入任务栈顶端，并处于Active状态，而启动它的Activity就被顶下去一个位置，处于Stoped状态（不可见的情况下），当当前Activity执行完后，即用户按下返回键或者调用了finish()方法后，当前Activity出栈，启动它的Activity就宠幸回到Active状态。\n\n这就是基于栈的后进先出的任务栈。\n\n### standard模式\n\n这是默认的加载模式，这种加载模式每次都会创建一个新的Activity，每创建一次，新的Activity就会覆盖在原有的Activity上。\n\n### singleTop模式\n\n我个人理解就相当与栈顶单实例模式，设置了这种模式的Activity，在启动时会先判断该Activity是否处于栈顶，如果处于栈顶就不会新建Activity实例，而是直接重新启动在栈顶的这个Activity，并调用onNewIntent()方法。\n\n### singleTask模式\n\nsingleTask模式和singleTop模式类似，不过与singleTop检测栈顶元素是否是需要启动的Activity不同的是，singleTask是检测整个Activity栈中是否存在需要启动的Activity，如果存在，就把该Activity顶到栈顶，在该Activity上的Activity都会出栈销毁。\n\n上面是对处于同一个应用中启动的singleTask模式的Activity的处理。\n\n对于在其他应用中启动singleTask模式的Activity，如果后台任务栈不存在要启动的Activity，那么将会创建一个新的任务栈，如果后台任务栈中存在要启动的Activity，该后台任务栈就会切换到前台。\n\n### singleInstance\n\nsingleInstance可以简单理解为singleTask的加强版，这个加载模式具备singleTask的所有特性，但在任务栈的处理上加强了，处于这种模式的Activity，每一个Activity都会单独处于一个任务栈中，而且那个任务栈中智能存在单个Activity。\n\n\n\n","slug":"Android/201603/ Android四大组件之一——Activity","published":1,"updated":"2016-03-21T16:25:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinisi4kf000h3ntfhlk7eyoh","content":"<blockquote>\n<p>Activity是Android的四大组件之一，这里将梳理一下有关Activity的东西</p>\n</blockquote>\n<h2 id=\"Activity的四种状态\"><a href=\"#Activity的四种状态\" class=\"headerlink\" title=\"Activity的四种状态\"></a>Activity的四种状态</h2><p><strong>Active状态：</strong>在这种状态的Activity，必须是在栈顶的，此时它是可视的，并且可以获取焦点和用户的输入，Android系统将会保证在这种状态的Activity有充分的资源，当资源不足时就会试图杀死其它Activity来提供足够的资源，当激活另一个Activity后，当前Active状态的Activity将会进入Paused状态。<br><a id=\"more\"></a><br><strong>Paused状态：</strong>当一个透明或者非全屏的Activity被激活时，前一个处于Active状态的Activity将会进入Paused状态，处于这种状态的Activity依然处于活动状态，只是不再能获取焦点和用户输入，如果当前被激活的Activity的资源足够的情况下，Android不会主动杀死处于Paused状态的Activity，当一个Activity变得完全不可见时，它将会进入Stoped状态。</p>\n<p><strong>Stoped状态：</strong>当一个Activity变得完全不可见，就代表它此时进入了Stoped状态。虽然此时该Activity被停止了，但内存中仍保存这这个Activity的所有信息，但当Android出现内存资源不足时，处于这种状态的Activity是最有可能被杀死的。当一个Activity退出或关闭了，就会进入Killed状态。</p>\n<p><strong>Killed状态：</strong>当一个Activity被退出了或者关闭了，就进入了这种状态，处于这种状态的Activity，在需要时可以重新启用它。</p>\n<h2 id=\"Activity生命周期\"><a href=\"#Activity生命周期\" class=\"headerlink\" title=\"Activity生命周期\"></a>Activity生命周期</h2><p><em>了解一个组件，生命周期这个一定要了解，才能更好地把握在什么时候该做什么事。</em></p>\n<p>说到生命周期，必然少不了这张图：</p>\n<h4 id=\"简单说明一下这张图：\"><a href=\"#简单说明一下这张图：\" class=\"headerlink\" title=\"简单说明一下这张图：\"></a>简单说明一下这张图：</h4><p><img src=\"http://i12.tietuku.cn/2bf48e46914376f0.png\" alt=\"\"></p>\n<ul>\n<li><p>当一个Activity启动后，系统会先调用Activity中的onCreate()方法，这个方法也是见得最多的。</p>\n</li>\n<li><p>执行完onCreate()方法后，系统会依次调用onStart()、onResume()方法，调用完这个方法后，一个Activity就算正式启动完成了，此时Activity显示在前台，也就是处于前面所说的四种状态中的Active状态。</p>\n</li>\n<li><p>当另一个Activity被激活，并占据前台时，当前处于Active状态的Activity将执行onPause()状态，此时也就是前面所说的四种状态中的Paused状态。此时如果系统资源不足，需要资源，很可能处于这个状态的Activity将被杀死，就进入了Killed状态，又或者，处于这个状态的Activity又重新回到前台，那么将重新调用onResume()方法，Activity将重新进入前台显示。</p>\n</li>\n<li><p>当一个Activity不再可见后，即执行该Activity的onStop()方法，执行该方法说明该Activity进入了前面四种状态中的Stoped状态，此时也跟Paused状态一样，有两种可能，只是这里在回到前台后，执行的不是onResume()方法，而是先执行onRestart()方法。然后执行onStart()方法，再执行onResume()方法。（我个人把这个理解为重新启动的过程，不知道这么理解有没有问题）</p>\n</li>\n<li><p>当用户退出Activity后，如果处于任何状态的Activity都会按照图示顺序执行下来，执行onStop()方法后，就会执行onDestory()方法，执行完onDestory()方法后，这个Activity将被正式关闭了。</p>\n</li>\n</ul>\n<h4 id=\"下面引用网上对这几种方法的介绍，来说明下这几种方法：\"><a href=\"#下面引用网上对这几种方法的介绍，来说明下这几种方法：\" class=\"headerlink\" title=\"下面引用网上对这几种方法的介绍，来说明下这几种方法：\"></a>下面引用网上对这几种方法的介绍，来说明下这几种方法：</h4><ul>\n<li><p>onCreate：当Activity第一次启动的时候，触发这个方法，可以在此时完成Activity的初始化工作。onCreate方法有一个参数，这个参数可以为空，也可以是之前调用onSaveInstanceState()方法保存的状态信息。</p>\n</li>\n<li><p>onStart：该方法的触发表示所属活动将被展现给用户。</p>\n</li>\n<li><p>onResume：当一个活动和用户发生交互时，就会触发该方法。</p>\n</li>\n<li><p>onPause：当一个正在前台运行的活动因为其他活动需要前台运行而转入后台运行的时候，触发该方法。这时候需要将活动的状态持久化，比如正在编辑的数据库记录等。</p>\n</li>\n<li><p>onStop：当一个活动不需要展示给用户的时候，就会触发该方法。如果内存紧张，系统会直接结束这个活动，而不会触发onStop方法。所以保存状态信息是应该在onPause时做，而不是onStop时候做。活动如果没有在前台运行，都将被停止或者Linux管理进程为了给新的活动预留足够的存储空间而随时结束这些活动，因此对于开发者来说，在设计应用程序的时候，必须时刻牢记这一原则。在一些情况下，onPause方法或许是活动触发的最后的方法，因此开发者需要在这个时候保存需要保存的信息。</p>\n</li>\n<li><p>onRestart：当处于停止状态的活动需要再次展现给用户的时候，触发该方法。</p>\n</li>\n<li><p>onDestory：当活动销毁的时候，触发该方法。和onStop方法一样，如果内存紧张，系统会直接结束这个活动而不会触发这个方法。</p>\n</li>\n</ul>\n<p>另：</p>\n<p><strong>onSaveInstanceState：</strong>系统调用该方法，允许活动保存之前的状态，比如说在一串字符串中的光标所处的位置等。</p>\n<p>通常情况下，开发者不需要重写覆盖该方法，在默认实现中，已经提供了自动保存活动所设计的用户界面组件的所有状态信息。</p>\n<h2 id=\"Activity的四种加载模式\"><a href=\"#Activity的四种加载模式\" class=\"headerlink\" title=\"Activity的四种加载模式\"></a>Activity的四种加载模式</h2><p>Activity提供了四种加载模式，分别为：standard、singleTop、singleTask、singleInstance模式。</p>\n<p>这四种模式都是在AndroidManifest.xml文件中通过android:lanchMode来指定的，在介绍这四种启动模式之前，有必要先来了解一个概念——<strong>Activity栈</strong></p>\n<h3 id=\"Activity栈\"><a href=\"#Activity栈\" class=\"headerlink\" title=\"Activity栈\"></a>Activity栈</h3><p>Android是通过栈来保存Activity的，栈底的元素就是整个任务的发起者。</p>\n<p>当一个应用启动时，如果当前没有该应用的任务栈，就会创建一个任务栈，有了任务栈后，这个应用所启动的Activity都将在这个任务栈中被管理。</p>\n<p>有一点需要注意的，一个任务栈中Activity可能来自不同应用，同一个应用的Activity也可能不再一个任务栈中。</p>\n<p>一般情况下，当一个任务栈中的一个Activity启动了另一个Activity的时候，新启动的Activity就会进入任务栈顶端，并处于Active状态，而启动它的Activity就被顶下去一个位置，处于Stoped状态（不可见的情况下），当当前Activity执行完后，即用户按下返回键或者调用了finish()方法后，当前Activity出栈，启动它的Activity就宠幸回到Active状态。</p>\n<p>这就是基于栈的后进先出的任务栈。</p>\n<h3 id=\"standard模式\"><a href=\"#standard模式\" class=\"headerlink\" title=\"standard模式\"></a>standard模式</h3><p>这是默认的加载模式，这种加载模式每次都会创建一个新的Activity，每创建一次，新的Activity就会覆盖在原有的Activity上。</p>\n<h3 id=\"singleTop模式\"><a href=\"#singleTop模式\" class=\"headerlink\" title=\"singleTop模式\"></a>singleTop模式</h3><p>我个人理解就相当与栈顶单实例模式，设置了这种模式的Activity，在启动时会先判断该Activity是否处于栈顶，如果处于栈顶就不会新建Activity实例，而是直接重新启动在栈顶的这个Activity，并调用onNewIntent()方法。</p>\n<h3 id=\"singleTask模式\"><a href=\"#singleTask模式\" class=\"headerlink\" title=\"singleTask模式\"></a>singleTask模式</h3><p>singleTask模式和singleTop模式类似，不过与singleTop检测栈顶元素是否是需要启动的Activity不同的是，singleTask是检测整个Activity栈中是否存在需要启动的Activity，如果存在，就把该Activity顶到栈顶，在该Activity上的Activity都会出栈销毁。</p>\n<p>上面是对处于同一个应用中启动的singleTask模式的Activity的处理。</p>\n<p>对于在其他应用中启动singleTask模式的Activity，如果后台任务栈不存在要启动的Activity，那么将会创建一个新的任务栈，如果后台任务栈中存在要启动的Activity，该后台任务栈就会切换到前台。</p>\n<h3 id=\"singleInstance\"><a href=\"#singleInstance\" class=\"headerlink\" title=\"singleInstance\"></a>singleInstance</h3><p>singleInstance可以简单理解为singleTask的加强版，这个加载模式具备singleTask的所有特性，但在任务栈的处理上加强了，处于这种模式的Activity，每一个Activity都会单独处于一个任务栈中，而且那个任务栈中智能存在单个Activity。</p>\n","excerpt":"<blockquote>\n<p>Activity是Android的四大组件之一，这里将梳理一下有关Activity的东西</p>\n</blockquote>\n<h2 id=\"Activity的四种状态\"><a href=\"#Activity的四种状态\" class=\"headerlink\" title=\"Activity的四种状态\"></a>Activity的四种状态</h2><p><strong>Active状态：</strong>在这种状态的Activity，必须是在栈顶的，此时它是可视的，并且可以获取焦点和用户的输入，Android系统将会保证在这种状态的Activity有充分的资源，当资源不足时就会试图杀死其它Activity来提供足够的资源，当激活另一个Activity后，当前Active状态的Activity将会进入Paused状态。<br>","more":"<br><strong>Paused状态：</strong>当一个透明或者非全屏的Activity被激活时，前一个处于Active状态的Activity将会进入Paused状态，处于这种状态的Activity依然处于活动状态，只是不再能获取焦点和用户输入，如果当前被激活的Activity的资源足够的情况下，Android不会主动杀死处于Paused状态的Activity，当一个Activity变得完全不可见时，它将会进入Stoped状态。</p>\n<p><strong>Stoped状态：</strong>当一个Activity变得完全不可见，就代表它此时进入了Stoped状态。虽然此时该Activity被停止了，但内存中仍保存这这个Activity的所有信息，但当Android出现内存资源不足时，处于这种状态的Activity是最有可能被杀死的。当一个Activity退出或关闭了，就会进入Killed状态。</p>\n<p><strong>Killed状态：</strong>当一个Activity被退出了或者关闭了，就进入了这种状态，处于这种状态的Activity，在需要时可以重新启用它。</p>\n<h2 id=\"Activity生命周期\"><a href=\"#Activity生命周期\" class=\"headerlink\" title=\"Activity生命周期\"></a>Activity生命周期</h2><p><em>了解一个组件，生命周期这个一定要了解，才能更好地把握在什么时候该做什么事。</em></p>\n<p>说到生命周期，必然少不了这张图：</p>\n<h4 id=\"简单说明一下这张图：\"><a href=\"#简单说明一下这张图：\" class=\"headerlink\" title=\"简单说明一下这张图：\"></a>简单说明一下这张图：</h4><p><img src=\"http://i12.tietuku.cn/2bf48e46914376f0.png\" alt=\"\"></p>\n<ul>\n<li><p>当一个Activity启动后，系统会先调用Activity中的onCreate()方法，这个方法也是见得最多的。</p>\n</li>\n<li><p>执行完onCreate()方法后，系统会依次调用onStart()、onResume()方法，调用完这个方法后，一个Activity就算正式启动完成了，此时Activity显示在前台，也就是处于前面所说的四种状态中的Active状态。</p>\n</li>\n<li><p>当另一个Activity被激活，并占据前台时，当前处于Active状态的Activity将执行onPause()状态，此时也就是前面所说的四种状态中的Paused状态。此时如果系统资源不足，需要资源，很可能处于这个状态的Activity将被杀死，就进入了Killed状态，又或者，处于这个状态的Activity又重新回到前台，那么将重新调用onResume()方法，Activity将重新进入前台显示。</p>\n</li>\n<li><p>当一个Activity不再可见后，即执行该Activity的onStop()方法，执行该方法说明该Activity进入了前面四种状态中的Stoped状态，此时也跟Paused状态一样，有两种可能，只是这里在回到前台后，执行的不是onResume()方法，而是先执行onRestart()方法。然后执行onStart()方法，再执行onResume()方法。（我个人把这个理解为重新启动的过程，不知道这么理解有没有问题）</p>\n</li>\n<li><p>当用户退出Activity后，如果处于任何状态的Activity都会按照图示顺序执行下来，执行onStop()方法后，就会执行onDestory()方法，执行完onDestory()方法后，这个Activity将被正式关闭了。</p>\n</li>\n</ul>\n<h4 id=\"下面引用网上对这几种方法的介绍，来说明下这几种方法：\"><a href=\"#下面引用网上对这几种方法的介绍，来说明下这几种方法：\" class=\"headerlink\" title=\"下面引用网上对这几种方法的介绍，来说明下这几种方法：\"></a>下面引用网上对这几种方法的介绍，来说明下这几种方法：</h4><ul>\n<li><p>onCreate：当Activity第一次启动的时候，触发这个方法，可以在此时完成Activity的初始化工作。onCreate方法有一个参数，这个参数可以为空，也可以是之前调用onSaveInstanceState()方法保存的状态信息。</p>\n</li>\n<li><p>onStart：该方法的触发表示所属活动将被展现给用户。</p>\n</li>\n<li><p>onResume：当一个活动和用户发生交互时，就会触发该方法。</p>\n</li>\n<li><p>onPause：当一个正在前台运行的活动因为其他活动需要前台运行而转入后台运行的时候，触发该方法。这时候需要将活动的状态持久化，比如正在编辑的数据库记录等。</p>\n</li>\n<li><p>onStop：当一个活动不需要展示给用户的时候，就会触发该方法。如果内存紧张，系统会直接结束这个活动，而不会触发onStop方法。所以保存状态信息是应该在onPause时做，而不是onStop时候做。活动如果没有在前台运行，都将被停止或者Linux管理进程为了给新的活动预留足够的存储空间而随时结束这些活动，因此对于开发者来说，在设计应用程序的时候，必须时刻牢记这一原则。在一些情况下，onPause方法或许是活动触发的最后的方法，因此开发者需要在这个时候保存需要保存的信息。</p>\n</li>\n<li><p>onRestart：当处于停止状态的活动需要再次展现给用户的时候，触发该方法。</p>\n</li>\n<li><p>onDestory：当活动销毁的时候，触发该方法。和onStop方法一样，如果内存紧张，系统会直接结束这个活动而不会触发这个方法。</p>\n</li>\n</ul>\n<p>另：</p>\n<p><strong>onSaveInstanceState：</strong>系统调用该方法，允许活动保存之前的状态，比如说在一串字符串中的光标所处的位置等。</p>\n<p>通常情况下，开发者不需要重写覆盖该方法，在默认实现中，已经提供了自动保存活动所设计的用户界面组件的所有状态信息。</p>\n<h2 id=\"Activity的四种加载模式\"><a href=\"#Activity的四种加载模式\" class=\"headerlink\" title=\"Activity的四种加载模式\"></a>Activity的四种加载模式</h2><p>Activity提供了四种加载模式，分别为：standard、singleTop、singleTask、singleInstance模式。</p>\n<p>这四种模式都是在AndroidManifest.xml文件中通过android:lanchMode来指定的，在介绍这四种启动模式之前，有必要先来了解一个概念——<strong>Activity栈</strong></p>\n<h3 id=\"Activity栈\"><a href=\"#Activity栈\" class=\"headerlink\" title=\"Activity栈\"></a>Activity栈</h3><p>Android是通过栈来保存Activity的，栈底的元素就是整个任务的发起者。</p>\n<p>当一个应用启动时，如果当前没有该应用的任务栈，就会创建一个任务栈，有了任务栈后，这个应用所启动的Activity都将在这个任务栈中被管理。</p>\n<p>有一点需要注意的，一个任务栈中Activity可能来自不同应用，同一个应用的Activity也可能不再一个任务栈中。</p>\n<p>一般情况下，当一个任务栈中的一个Activity启动了另一个Activity的时候，新启动的Activity就会进入任务栈顶端，并处于Active状态，而启动它的Activity就被顶下去一个位置，处于Stoped状态（不可见的情况下），当当前Activity执行完后，即用户按下返回键或者调用了finish()方法后，当前Activity出栈，启动它的Activity就宠幸回到Active状态。</p>\n<p>这就是基于栈的后进先出的任务栈。</p>\n<h3 id=\"standard模式\"><a href=\"#standard模式\" class=\"headerlink\" title=\"standard模式\"></a>standard模式</h3><p>这是默认的加载模式，这种加载模式每次都会创建一个新的Activity，每创建一次，新的Activity就会覆盖在原有的Activity上。</p>\n<h3 id=\"singleTop模式\"><a href=\"#singleTop模式\" class=\"headerlink\" title=\"singleTop模式\"></a>singleTop模式</h3><p>我个人理解就相当与栈顶单实例模式，设置了这种模式的Activity，在启动时会先判断该Activity是否处于栈顶，如果处于栈顶就不会新建Activity实例，而是直接重新启动在栈顶的这个Activity，并调用onNewIntent()方法。</p>\n<h3 id=\"singleTask模式\"><a href=\"#singleTask模式\" class=\"headerlink\" title=\"singleTask模式\"></a>singleTask模式</h3><p>singleTask模式和singleTop模式类似，不过与singleTop检测栈顶元素是否是需要启动的Activity不同的是，singleTask是检测整个Activity栈中是否存在需要启动的Activity，如果存在，就把该Activity顶到栈顶，在该Activity上的Activity都会出栈销毁。</p>\n<p>上面是对处于同一个应用中启动的singleTask模式的Activity的处理。</p>\n<p>对于在其他应用中启动singleTask模式的Activity，如果后台任务栈不存在要启动的Activity，那么将会创建一个新的任务栈，如果后台任务栈中存在要启动的Activity，该后台任务栈就会切换到前台。</p>\n<h3 id=\"singleInstance\"><a href=\"#singleInstance\" class=\"headerlink\" title=\"singleInstance\"></a>singleInstance</h3><p>singleInstance可以简单理解为singleTask的加强版，这个加载模式具备singleTask的所有特性，但在任务栈的处理上加强了，处于这种模式的Activity，每一个Activity都会单独处于一个任务栈中，而且那个任务栈中智能存在单个Activity。</p>"},{"title":"RxJava初步学习总结","date":"2016-03-12T16:00:00.000Z","author":"KevinWu","_content":"** 我们常用的对按钮事件的监听就是观察者模式的一个例子，对于观察者模式，简单的说就是有一个观察者，有个可以被当做观察的对象，这之间通过注册（register）或者订阅（subscribe）的方式进行绑定，当被观察的对象发生改变时，观察者就根据对象的动作做出相应的响应。 **\n\n在OnClickListener事件中，Button作为被观察者，onClickListener作为观察者，通过setOnClickListener订阅，onClick就是被观察者有动作后做出的相应事件。\n<!--more-->\n\n\n由此，引入RxJava中的拓展的观察者模式。\n\n在RxJava中，角色对应如下：\n\n观察者：Observer\n\n被观察者：Observable\n\n订阅：subscribe\n\n响应：onNext()——普通响应\nonCompleted()——事件队列完结响应\nonError()——事件队列异常响应\n\n（onCompleted()和onError()这两个方法只会调用其中一个，这也很好理解，完结了就肯定没有异常嘛！）\n\n\n\n### 创建一个Observer（观察者）\n\n先看一下observer接口的实现：\n\n``` java\nObserver<String> observer =new Observer<String>(){\n\n    @override\n\n    public void onNext(String s){\n\n        Log.d(TAG,\"Item is :\"+s);\n\n    }\n\n    @override\n\n    public void onCompleted(){\n\n        Log.d(TAG,\"All things are completed!\");\n\n    }    \n\n    @override\n\n    public void onError(Throwable e){\n\n        Log.d(TAG,\"Opps! Somethings is error!\");\n\n    }\n\n}\n```\n\n除了Observer接口，RxJava还有一个Subscriber，翻译过来就是注册者，和观察者一个道理，不过在这里它是一个Observer接口实现的抽象类，只是针对Observer进行了一些扩展，基本的使用方式一样。\n\n\n\n在RxJava的订阅（subscribe）过程中，一个Observer也会被转化成Subscriber再使用，但他们也有点区别：\n\n* onStart()：这个是Subscriber新增的方法，会在订阅subscribe刚开始时被调用，可以在这里面做一些准备工作，如对数据进行清零或者重置。需要注意的是这个方法只能在subscribe线程中调用。\n\n\n\n* unsubscribe()：这是Subscriber实现另一个接口Subscription的方法，用来取消订阅。这个方法被调用以后，Subscriber将不再继续观察（接收事件）。一般执行这个方法前，应该使用isUnsubscribed()先判断一下状态。unsubscribe()这个方法的使用可以避免内存泄露情况的发生。\n\n\n\n### 创建一个Observable（被观察者）\n\nRxJava使用create()方法来创建一个Observable并定义触发规则，下面看看怎么创建一个被观察的对象：\n\n``` java\nObservable observable = Observable.create(new Observable.OnSubscribe<String>(){\n\n    @override\n\n    public void call(Subscriber<? super String> subscriber){\n\n        subscriber.onNext(\"Hello\");\n\n        subscriber.onNext(\"Hi\");\n\n        subscriber.onCompleted();\n\n    }\n\n});\n```\n\n这里传入一个OnSubscribe对象作为参数，OnSubscribe会被存储在返回的Observable的对象observable中，它的作用相当与一个计划表，当Observable被订阅的时候，OnSubscribe的call方法会自动被调用，事件序列就会依照设定依次触发。这样由被观察者触发了观察者的回调方法，这样就实现了由被观察者向观察者的事件传递。\n\nRxJava还提供了几个快捷创建事件队列的方法，如果要实现上面的功能，还可以使用以下两种方法：\n\n``` java \nObservable observable=Observable.just(\"Hello\",\"Hi\");\n```\n\n\n\n``` java\n\nString [] info={\"Hello\",\"Hi\"};\nObservable observable=Observable.from(info);\n```\n### Subscribe（订阅）\n\n订阅后，就将Observer和Observable联结起来了，这个过程就可以正常工作了，订阅的代码如下：\n\n``` java\nobservable.subscribe(observer);\n//或者subscriber，具体看用了哪个\nobservable.subscribe(subscriber);\n```\n\n需要注意的是，这里换成语义是被观察者订阅了观察者，而不是观察者订阅被观察者。\n\n\n\nobservable.subscribe(subscriber)内部实现中做了三件事：\n\n1. 调用Subscriber.onStart()方法\n\n2. 调用Observable的OnSubscribe.call(Subscriber)方法。在RxJava中，Observable不是一创建就会发送事件，而是在它被订阅的时候，即subscribe()方法被执行的时候\n\n3. 将传入的Subscriber作为Subscription返回，这里可以方便执行unsubscribe()\n\n\n\n以上是一个RxJava的学习简单总结，更深入的总结后续继续进行。\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Android/201603/RxJava初步学习总结.md","raw":"---\ntitle: RxJava初步学习总结\ndate: 2016-03-13\nauthor:  KevinWu\ncategories: Android\ntags: \n\t- Java \n\t- RxJava\n---\n** 我们常用的对按钮事件的监听就是观察者模式的一个例子，对于观察者模式，简单的说就是有一个观察者，有个可以被当做观察的对象，这之间通过注册（register）或者订阅（subscribe）的方式进行绑定，当被观察的对象发生改变时，观察者就根据对象的动作做出相应的响应。 **\n\n在OnClickListener事件中，Button作为被观察者，onClickListener作为观察者，通过setOnClickListener订阅，onClick就是被观察者有动作后做出的相应事件。\n<!--more-->\n\n\n由此，引入RxJava中的拓展的观察者模式。\n\n在RxJava中，角色对应如下：\n\n观察者：Observer\n\n被观察者：Observable\n\n订阅：subscribe\n\n响应：onNext()——普通响应\nonCompleted()——事件队列完结响应\nonError()——事件队列异常响应\n\n（onCompleted()和onError()这两个方法只会调用其中一个，这也很好理解，完结了就肯定没有异常嘛！）\n\n\n\n### 创建一个Observer（观察者）\n\n先看一下observer接口的实现：\n\n``` java\nObserver<String> observer =new Observer<String>(){\n\n    @override\n\n    public void onNext(String s){\n\n        Log.d(TAG,\"Item is :\"+s);\n\n    }\n\n    @override\n\n    public void onCompleted(){\n\n        Log.d(TAG,\"All things are completed!\");\n\n    }    \n\n    @override\n\n    public void onError(Throwable e){\n\n        Log.d(TAG,\"Opps! Somethings is error!\");\n\n    }\n\n}\n```\n\n除了Observer接口，RxJava还有一个Subscriber，翻译过来就是注册者，和观察者一个道理，不过在这里它是一个Observer接口实现的抽象类，只是针对Observer进行了一些扩展，基本的使用方式一样。\n\n\n\n在RxJava的订阅（subscribe）过程中，一个Observer也会被转化成Subscriber再使用，但他们也有点区别：\n\n* onStart()：这个是Subscriber新增的方法，会在订阅subscribe刚开始时被调用，可以在这里面做一些准备工作，如对数据进行清零或者重置。需要注意的是这个方法只能在subscribe线程中调用。\n\n\n\n* unsubscribe()：这是Subscriber实现另一个接口Subscription的方法，用来取消订阅。这个方法被调用以后，Subscriber将不再继续观察（接收事件）。一般执行这个方法前，应该使用isUnsubscribed()先判断一下状态。unsubscribe()这个方法的使用可以避免内存泄露情况的发生。\n\n\n\n### 创建一个Observable（被观察者）\n\nRxJava使用create()方法来创建一个Observable并定义触发规则，下面看看怎么创建一个被观察的对象：\n\n``` java\nObservable observable = Observable.create(new Observable.OnSubscribe<String>(){\n\n    @override\n\n    public void call(Subscriber<? super String> subscriber){\n\n        subscriber.onNext(\"Hello\");\n\n        subscriber.onNext(\"Hi\");\n\n        subscriber.onCompleted();\n\n    }\n\n});\n```\n\n这里传入一个OnSubscribe对象作为参数，OnSubscribe会被存储在返回的Observable的对象observable中，它的作用相当与一个计划表，当Observable被订阅的时候，OnSubscribe的call方法会自动被调用，事件序列就会依照设定依次触发。这样由被观察者触发了观察者的回调方法，这样就实现了由被观察者向观察者的事件传递。\n\nRxJava还提供了几个快捷创建事件队列的方法，如果要实现上面的功能，还可以使用以下两种方法：\n\n``` java \nObservable observable=Observable.just(\"Hello\",\"Hi\");\n```\n\n\n\n``` java\n\nString [] info={\"Hello\",\"Hi\"};\nObservable observable=Observable.from(info);\n```\n### Subscribe（订阅）\n\n订阅后，就将Observer和Observable联结起来了，这个过程就可以正常工作了，订阅的代码如下：\n\n``` java\nobservable.subscribe(observer);\n//或者subscriber，具体看用了哪个\nobservable.subscribe(subscriber);\n```\n\n需要注意的是，这里换成语义是被观察者订阅了观察者，而不是观察者订阅被观察者。\n\n\n\nobservable.subscribe(subscriber)内部实现中做了三件事：\n\n1. 调用Subscriber.onStart()方法\n\n2. 调用Observable的OnSubscribe.call(Subscriber)方法。在RxJava中，Observable不是一创建就会发送事件，而是在它被订阅的时候，即subscribe()方法被执行的时候\n\n3. 将传入的Subscriber作为Subscription返回，这里可以方便执行unsubscribe()\n\n\n\n以上是一个RxJava的学习简单总结，更深入的总结后续继续进行。\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Android/201603/RxJava初步学习总结","published":1,"updated":"2016-03-26T12:06:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinisi4kp000q3ntfs4dk6c84","content":"<p><strong> 我们常用的对按钮事件的监听就是观察者模式的一个例子，对于观察者模式，简单的说就是有一个观察者，有个可以被当做观察的对象，这之间通过注册（register）或者订阅（subscribe）的方式进行绑定，当被观察的对象发生改变时，观察者就根据对象的动作做出相应的响应。 </strong></p>\n<p>在OnClickListener事件中，Button作为被观察者，onClickListener作为观察者，通过setOnClickListener订阅，onClick就是被观察者有动作后做出的相应事件。<br><a id=\"more\"></a></p>\n<p>由此，引入RxJava中的拓展的观察者模式。</p>\n<p>在RxJava中，角色对应如下：</p>\n<p>观察者：Observer</p>\n<p>被观察者：Observable</p>\n<p>订阅：subscribe</p>\n<p>响应：onNext()——普通响应<br>onCompleted()——事件队列完结响应<br>onError()——事件队列异常响应</p>\n<p>（onCompleted()和onError()这两个方法只会调用其中一个，这也很好理解，完结了就肯定没有异常嘛！）</p>\n<h3 id=\"创建一个Observer（观察者）\"><a href=\"#创建一个Observer（观察者）\" class=\"headerlink\" title=\"创建一个Observer（观察者）\"></a>创建一个Observer（观察者）</h3><p>先看一下observer接口的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observer&lt;String&gt; observer =<span class=\"keyword\">new</span> Observer&lt;String&gt;()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@override</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Log.d(TAG,<span class=\"string\">\"Item is :\"</span>+s);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@override</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Log.d(TAG,<span class=\"string\">\"All things are completed!\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@override</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Log.d(TAG,<span class=\"string\">\"Opps! Somethings is error!\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了Observer接口，RxJava还有一个Subscriber，翻译过来就是注册者，和观察者一个道理，不过在这里它是一个Observer接口实现的抽象类，只是针对Observer进行了一些扩展，基本的使用方式一样。</p>\n<p>在RxJava的订阅（subscribe）过程中，一个Observer也会被转化成Subscriber再使用，但他们也有点区别：</p>\n<ul>\n<li>onStart()：这个是Subscriber新增的方法，会在订阅subscribe刚开始时被调用，可以在这里面做一些准备工作，如对数据进行清零或者重置。需要注意的是这个方法只能在subscribe线程中调用。</li>\n</ul>\n<ul>\n<li>unsubscribe()：这是Subscriber实现另一个接口Subscription的方法，用来取消订阅。这个方法被调用以后，Subscriber将不再继续观察（接收事件）。一般执行这个方法前，应该使用isUnsubscribed()先判断一下状态。unsubscribe()这个方法的使用可以避免内存泄露情况的发生。</li>\n</ul>\n<h3 id=\"创建一个Observable（被观察者）\"><a href=\"#创建一个Observable（被观察者）\" class=\"headerlink\" title=\"创建一个Observable（被观察者）\"></a>创建一个Observable（被观察者）</h3><p>RxJava使用create()方法来创建一个Observable并定义触发规则，下面看看怎么创建一个被观察的对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable observable = Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;String&gt;()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@override</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> String&gt; subscriber)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        subscriber.onNext(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        subscriber.onNext(<span class=\"string\">\"Hi\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        subscriber.onCompleted();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里传入一个OnSubscribe对象作为参数，OnSubscribe会被存储在返回的Observable的对象observable中，它的作用相当与一个计划表，当Observable被订阅的时候，OnSubscribe的call方法会自动被调用，事件序列就会依照设定依次触发。这样由被观察者触发了观察者的回调方法，这样就实现了由被观察者向观察者的事件传递。</p>\n<p>RxJava还提供了几个快捷创建事件队列的方法，如果要实现上面的功能，还可以使用以下两种方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable observable=Observable.just(<span class=\"string\">\"Hello\"</span>,<span class=\"string\">\"Hi\"</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">String [] info=&#123;<span class=\"string\">\"Hello\"</span>,<span class=\"string\">\"Hi\"</span>&#125;;</span><br><span class=\"line\">Observable observable=Observable.from(info);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Subscribe（订阅）\"><a href=\"#Subscribe（订阅）\" class=\"headerlink\" title=\"Subscribe（订阅）\"></a>Subscribe（订阅）</h3><p>订阅后，就将Observer和Observable联结起来了，这个过程就可以正常工作了，订阅的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">observable.subscribe(observer);</span><br><span class=\"line\"><span class=\"comment\">//或者subscriber，具体看用了哪个</span></span><br><span class=\"line\">observable.subscribe(subscriber);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，这里换成语义是被观察者订阅了观察者，而不是观察者订阅被观察者。</p>\n<p>observable.subscribe(subscriber)内部实现中做了三件事：</p>\n<ol>\n<li><p>调用Subscriber.onStart()方法</p>\n</li>\n<li><p>调用Observable的OnSubscribe.call(Subscriber)方法。在RxJava中，Observable不是一创建就会发送事件，而是在它被订阅的时候，即subscribe()方法被执行的时候</p>\n</li>\n<li><p>将传入的Subscriber作为Subscription返回，这里可以方便执行unsubscribe()</p>\n</li>\n</ol>\n<p>以上是一个RxJava的学习简单总结，更深入的总结后续继续进行。</p>\n","excerpt":"<p><strong> 我们常用的对按钮事件的监听就是观察者模式的一个例子，对于观察者模式，简单的说就是有一个观察者，有个可以被当做观察的对象，这之间通过注册（register）或者订阅（subscribe）的方式进行绑定，当被观察的对象发生改变时，观察者就根据对象的动作做出相应的响应。 </strong></p>\n<p>在OnClickListener事件中，Button作为被观察者，onClickListener作为观察者，通过setOnClickListener订阅，onClick就是被观察者有动作后做出的相应事件。<br>","more":"</p>\n<p>由此，引入RxJava中的拓展的观察者模式。</p>\n<p>在RxJava中，角色对应如下：</p>\n<p>观察者：Observer</p>\n<p>被观察者：Observable</p>\n<p>订阅：subscribe</p>\n<p>响应：onNext()——普通响应<br>onCompleted()——事件队列完结响应<br>onError()——事件队列异常响应</p>\n<p>（onCompleted()和onError()这两个方法只会调用其中一个，这也很好理解，完结了就肯定没有异常嘛！）</p>\n<h3 id=\"创建一个Observer（观察者）\"><a href=\"#创建一个Observer（观察者）\" class=\"headerlink\" title=\"创建一个Observer（观察者）\"></a>创建一个Observer（观察者）</h3><p>先看一下observer接口的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observer&lt;String&gt; observer =<span class=\"keyword\">new</span> Observer&lt;String&gt;()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@override</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Log.d(TAG,<span class=\"string\">\"Item is :\"</span>+s);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@override</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Log.d(TAG,<span class=\"string\">\"All things are completed!\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@override</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Log.d(TAG,<span class=\"string\">\"Opps! Somethings is error!\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了Observer接口，RxJava还有一个Subscriber，翻译过来就是注册者，和观察者一个道理，不过在这里它是一个Observer接口实现的抽象类，只是针对Observer进行了一些扩展，基本的使用方式一样。</p>\n<p>在RxJava的订阅（subscribe）过程中，一个Observer也会被转化成Subscriber再使用，但他们也有点区别：</p>\n<ul>\n<li>onStart()：这个是Subscriber新增的方法，会在订阅subscribe刚开始时被调用，可以在这里面做一些准备工作，如对数据进行清零或者重置。需要注意的是这个方法只能在subscribe线程中调用。</li>\n</ul>\n<ul>\n<li>unsubscribe()：这是Subscriber实现另一个接口Subscription的方法，用来取消订阅。这个方法被调用以后，Subscriber将不再继续观察（接收事件）。一般执行这个方法前，应该使用isUnsubscribed()先判断一下状态。unsubscribe()这个方法的使用可以避免内存泄露情况的发生。</li>\n</ul>\n<h3 id=\"创建一个Observable（被观察者）\"><a href=\"#创建一个Observable（被观察者）\" class=\"headerlink\" title=\"创建一个Observable（被观察者）\"></a>创建一个Observable（被观察者）</h3><p>RxJava使用create()方法来创建一个Observable并定义触发规则，下面看看怎么创建一个被观察的对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable observable = Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;String&gt;()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@override</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> String&gt; subscriber)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        subscriber.onNext(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        subscriber.onNext(<span class=\"string\">\"Hi\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        subscriber.onCompleted();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里传入一个OnSubscribe对象作为参数，OnSubscribe会被存储在返回的Observable的对象observable中，它的作用相当与一个计划表，当Observable被订阅的时候，OnSubscribe的call方法会自动被调用，事件序列就会依照设定依次触发。这样由被观察者触发了观察者的回调方法，这样就实现了由被观察者向观察者的事件传递。</p>\n<p>RxJava还提供了几个快捷创建事件队列的方法，如果要实现上面的功能，还可以使用以下两种方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable observable=Observable.just(<span class=\"string\">\"Hello\"</span>,<span class=\"string\">\"Hi\"</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">String [] info=&#123;<span class=\"string\">\"Hello\"</span>,<span class=\"string\">\"Hi\"</span>&#125;;</span><br><span class=\"line\">Observable observable=Observable.from(info);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Subscribe（订阅）\"><a href=\"#Subscribe（订阅）\" class=\"headerlink\" title=\"Subscribe（订阅）\"></a>Subscribe（订阅）</h3><p>订阅后，就将Observer和Observable联结起来了，这个过程就可以正常工作了，订阅的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">observable.subscribe(observer);</span><br><span class=\"line\"><span class=\"comment\">//或者subscriber，具体看用了哪个</span></span><br><span class=\"line\">observable.subscribe(subscriber);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，这里换成语义是被观察者订阅了观察者，而不是观察者订阅被观察者。</p>\n<p>observable.subscribe(subscriber)内部实现中做了三件事：</p>\n<ol>\n<li><p>调用Subscriber.onStart()方法</p>\n</li>\n<li><p>调用Observable的OnSubscribe.call(Subscriber)方法。在RxJava中，Observable不是一创建就会发送事件，而是在它被订阅的时候，即subscribe()方法被执行的时候</p>\n</li>\n<li><p>将传入的Subscriber作为Subscription返回，这里可以方便执行unsubscribe()</p>\n</li>\n</ol>\n<p>以上是一个RxJava的学习简单总结，更深入的总结后续继续进行。</p>"},{"title":"JVM简单个人总结（一）","date":"2016-03-15T16:00:00.000Z","author":"KevinWu","_content":"说明：这篇文章只是个人对JVM的初步探讨总结，很多概念来自网络，加入部分个人理解，也许个人理解的地方有误，也恳请看到的同学帮忙指出，关于JVM的具体知识可以阅读《深入理解Java虚拟机：JVM高级特性与最佳性能》这本书籍。\n<!--more-->\n\n\n---\n\n\n\n# JVM\n\nJVM是Java Virtual Machine的缩写，中文名为java虚拟机，JVM是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。它与VirtualBox那些虚拟PC机的虚拟机又有点区别，它只设置了4个常用的寄存器，分别为：pc程序计数器，optop操作数寄存器，frame当前执行环境指针和vars当前执行环境中的第一个局部变量指针。\n\njava语言的一个非常重要的特点是平台无关性，而使用java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入java虚拟机后，java语言在不同平台上运行时就不需要重新编译。Java实用java虚拟机屏蔽了与具体平台的信息，使得java语言编译程序只需生成java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。java虚拟机在执行字节码时，把字节码翻译成具体平台上的机器指令执行。这就是java能够“一次编译，到处运行”的原因。\n\n\n\n# JRE/JDK/JVM的关系\n\nJRE（Java Runtime Environment）：中文名为java运行是环境，也就是java平台。所有的java程序都要在有jre的环境下才能运行。\n\nJDK（Java Development Kit）：中文名为java开发工具，jdk的工具也是java程序，也需要jre环境才能运行。\n\nJVM（Java Virtual Machine）：中文名为java虚拟机，这个是jre的一部分。\n\n\n\n# JVM环境的加载\n\n以windows操作系统为例，装入JVM是通过jdk中的Java.exe可执行程序来完成的，具体可以分为四步：\n\n1. 创建JVM装载环境和配置\n\n2. 装载JVM.dll\n\n3. 初始化JVM.dll并挂到JNIENV（JNI调用接口）实例\n\n4. 调用JNIENV实例装载并处理class类\n\n\n\n关于这个更详细的信息可以参考这篇文章：http://blog.csdn.net/ye1992/article/details/38228393\n\n\n\n# JVM的生命周期\n\n当一个Java程序启动时，一个JVM实例就产生了，任何存在public static void main(String [] args)方法的类都可以作为JVM实例运行的起点，所以在平时定义一个Class时就要显示告诉JVM类名，这样JVM才能知道是该运行哪个类里面的main方法。\n\nmain()方法是初始线程的起点，任何其它线程均由该线程启动。JVM内部存在两种线程，分别为守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，Java程序也可以标明自己创建的线程是守护线程。\n\n当程序中的所有非守护线程都终止时，JVM才退出，程序中也可以使用setDaemon(boolean on)方法来设定为守护线程。（Linux中说守护进程，这里为什么说守护线程呢？因为，java是跑在JVM虚拟机上的）。\n\n\n\n# JVM体系结构\n\nJVM内部分成三部分，分别为：类装载器（ClassLoader）子系统、执行引擎和运行时数据区。\n\n- 类装载器子系统：就是用来装载.class文件的系统。JVM的两种装载器包括：启动类装载器和用户自定义类装载器。启动类装载器是JVM实现的一部分，用户自定义类装载器则是java程序的一部分，必须是ClassLoader类的子类。\n\n- 执行引擎：执行引擎是Java虚拟机核心组成部分之一，输入的是字节码文件，处理过程就是字节码解析的等效过程，输出的是执行结果，对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法。执行引擎所运行的所有字节码指令都是针对当前栈帧进行操作。\n\n- 运行时数据区：主要有方法区、堆、Java栈、PC寄存器、本地方法栈。\n\n\n\n## 对运行时数据区进行些补充：\n\n1. 方法区和堆由所有线程共享\n\n2. Java栈和PC寄存器由线程独享，在新线程的创建的时间里\n\n3. 本地方法栈：存储本地方法调用的状态\n\n\n\n## JVM中的数据类型：\n\nJVM中的基本数据单元是word，而word的长度由JVM的具体实现者来决定。\n\n*数据类型包括基本类型和引用类型：*\n\n- 基本数据类型包括：数值类型（除boolean外的所有java基本数据类型），boolean在JVM中使用int来表示，0表示false，其他值均表示true，还有一个returnAddress类型，这个是JVM的内部类型，用来实现finally子句。\n\n- 引用类型包括：数组类型、类类型、接口类型\n\n\n\n\n\n\n\n\n\n","source":"_posts/Java/201603/JVM简单个人总结（一）.md","raw":"---\ntitle: JVM简单个人总结（一）\ndate: 2016-03-16\nauthor:  KevinWu\ncategories: Java\ntags: \n\t- Java \n\t- JVM \n\t- 虚拟机\n---\n说明：这篇文章只是个人对JVM的初步探讨总结，很多概念来自网络，加入部分个人理解，也许个人理解的地方有误，也恳请看到的同学帮忙指出，关于JVM的具体知识可以阅读《深入理解Java虚拟机：JVM高级特性与最佳性能》这本书籍。\n<!--more-->\n\n\n---\n\n\n\n# JVM\n\nJVM是Java Virtual Machine的缩写，中文名为java虚拟机，JVM是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。它与VirtualBox那些虚拟PC机的虚拟机又有点区别，它只设置了4个常用的寄存器，分别为：pc程序计数器，optop操作数寄存器，frame当前执行环境指针和vars当前执行环境中的第一个局部变量指针。\n\njava语言的一个非常重要的特点是平台无关性，而使用java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入java虚拟机后，java语言在不同平台上运行时就不需要重新编译。Java实用java虚拟机屏蔽了与具体平台的信息，使得java语言编译程序只需生成java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。java虚拟机在执行字节码时，把字节码翻译成具体平台上的机器指令执行。这就是java能够“一次编译，到处运行”的原因。\n\n\n\n# JRE/JDK/JVM的关系\n\nJRE（Java Runtime Environment）：中文名为java运行是环境，也就是java平台。所有的java程序都要在有jre的环境下才能运行。\n\nJDK（Java Development Kit）：中文名为java开发工具，jdk的工具也是java程序，也需要jre环境才能运行。\n\nJVM（Java Virtual Machine）：中文名为java虚拟机，这个是jre的一部分。\n\n\n\n# JVM环境的加载\n\n以windows操作系统为例，装入JVM是通过jdk中的Java.exe可执行程序来完成的，具体可以分为四步：\n\n1. 创建JVM装载环境和配置\n\n2. 装载JVM.dll\n\n3. 初始化JVM.dll并挂到JNIENV（JNI调用接口）实例\n\n4. 调用JNIENV实例装载并处理class类\n\n\n\n关于这个更详细的信息可以参考这篇文章：http://blog.csdn.net/ye1992/article/details/38228393\n\n\n\n# JVM的生命周期\n\n当一个Java程序启动时，一个JVM实例就产生了，任何存在public static void main(String [] args)方法的类都可以作为JVM实例运行的起点，所以在平时定义一个Class时就要显示告诉JVM类名，这样JVM才能知道是该运行哪个类里面的main方法。\n\nmain()方法是初始线程的起点，任何其它线程均由该线程启动。JVM内部存在两种线程，分别为守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，Java程序也可以标明自己创建的线程是守护线程。\n\n当程序中的所有非守护线程都终止时，JVM才退出，程序中也可以使用setDaemon(boolean on)方法来设定为守护线程。（Linux中说守护进程，这里为什么说守护线程呢？因为，java是跑在JVM虚拟机上的）。\n\n\n\n# JVM体系结构\n\nJVM内部分成三部分，分别为：类装载器（ClassLoader）子系统、执行引擎和运行时数据区。\n\n- 类装载器子系统：就是用来装载.class文件的系统。JVM的两种装载器包括：启动类装载器和用户自定义类装载器。启动类装载器是JVM实现的一部分，用户自定义类装载器则是java程序的一部分，必须是ClassLoader类的子类。\n\n- 执行引擎：执行引擎是Java虚拟机核心组成部分之一，输入的是字节码文件，处理过程就是字节码解析的等效过程，输出的是执行结果，对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法。执行引擎所运行的所有字节码指令都是针对当前栈帧进行操作。\n\n- 运行时数据区：主要有方法区、堆、Java栈、PC寄存器、本地方法栈。\n\n\n\n## 对运行时数据区进行些补充：\n\n1. 方法区和堆由所有线程共享\n\n2. Java栈和PC寄存器由线程独享，在新线程的创建的时间里\n\n3. 本地方法栈：存储本地方法调用的状态\n\n\n\n## JVM中的数据类型：\n\nJVM中的基本数据单元是word，而word的长度由JVM的具体实现者来决定。\n\n*数据类型包括基本类型和引用类型：*\n\n- 基本数据类型包括：数值类型（除boolean外的所有java基本数据类型），boolean在JVM中使用int来表示，0表示false，其他值均表示true，还有一个returnAddress类型，这个是JVM的内部类型，用来实现finally子句。\n\n- 引用类型包括：数组类型、类类型、接口类型\n\n\n\n\n\n\n\n\n\n","slug":"Java/201603/JVM简单个人总结（一）","published":1,"updated":"2016-03-18T07:24:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinisi4ks000v3ntfm2ye5yvf","content":"<p>说明：这篇文章只是个人对JVM的初步探讨总结，很多概念来自网络，加入部分个人理解，也许个人理解的地方有误，也恳请看到的同学帮忙指出，关于JVM的具体知识可以阅读《深入理解Java虚拟机：JVM高级特性与最佳性能》这本书籍。<br><a id=\"more\"></a></p>\n<hr>\n<h1 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h1><p>JVM是Java Virtual Machine的缩写，中文名为java虚拟机，JVM是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。它与VirtualBox那些虚拟PC机的虚拟机又有点区别，它只设置了4个常用的寄存器，分别为：pc程序计数器，optop操作数寄存器，frame当前执行环境指针和vars当前执行环境中的第一个局部变量指针。</p>\n<p>java语言的一个非常重要的特点是平台无关性，而使用java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入java虚拟机后，java语言在不同平台上运行时就不需要重新编译。Java实用java虚拟机屏蔽了与具体平台的信息，使得java语言编译程序只需生成java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。java虚拟机在执行字节码时，把字节码翻译成具体平台上的机器指令执行。这就是java能够“一次编译，到处运行”的原因。</p>\n<h1 id=\"JRE-JDK-JVM的关系\"><a href=\"#JRE-JDK-JVM的关系\" class=\"headerlink\" title=\"JRE/JDK/JVM的关系\"></a>JRE/JDK/JVM的关系</h1><p>JRE（Java Runtime Environment）：中文名为java运行是环境，也就是java平台。所有的java程序都要在有jre的环境下才能运行。</p>\n<p>JDK（Java Development Kit）：中文名为java开发工具，jdk的工具也是java程序，也需要jre环境才能运行。</p>\n<p>JVM（Java Virtual Machine）：中文名为java虚拟机，这个是jre的一部分。</p>\n<h1 id=\"JVM环境的加载\"><a href=\"#JVM环境的加载\" class=\"headerlink\" title=\"JVM环境的加载\"></a>JVM环境的加载</h1><p>以windows操作系统为例，装入JVM是通过jdk中的Java.exe可执行程序来完成的，具体可以分为四步：</p>\n<ol>\n<li><p>创建JVM装载环境和配置</p>\n</li>\n<li><p>装载JVM.dll</p>\n</li>\n<li><p>初始化JVM.dll并挂到JNIENV（JNI调用接口）实例</p>\n</li>\n<li><p>调用JNIENV实例装载并处理class类</p>\n</li>\n</ol>\n<p>关于这个更详细的信息可以参考这篇文章：<a href=\"http://blog.csdn.net/ye1992/article/details/38228393\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ye1992/article/details/38228393</a></p>\n<h1 id=\"JVM的生命周期\"><a href=\"#JVM的生命周期\" class=\"headerlink\" title=\"JVM的生命周期\"></a>JVM的生命周期</h1><p>当一个Java程序启动时，一个JVM实例就产生了，任何存在public static void main(String [] args)方法的类都可以作为JVM实例运行的起点，所以在平时定义一个Class时就要显示告诉JVM类名，这样JVM才能知道是该运行哪个类里面的main方法。</p>\n<p>main()方法是初始线程的起点，任何其它线程均由该线程启动。JVM内部存在两种线程，分别为守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，Java程序也可以标明自己创建的线程是守护线程。</p>\n<p>当程序中的所有非守护线程都终止时，JVM才退出，程序中也可以使用setDaemon(boolean on)方法来设定为守护线程。（Linux中说守护进程，这里为什么说守护线程呢？因为，java是跑在JVM虚拟机上的）。</p>\n<h1 id=\"JVM体系结构\"><a href=\"#JVM体系结构\" class=\"headerlink\" title=\"JVM体系结构\"></a>JVM体系结构</h1><p>JVM内部分成三部分，分别为：类装载器（ClassLoader）子系统、执行引擎和运行时数据区。</p>\n<ul>\n<li><p>类装载器子系统：就是用来装载.class文件的系统。JVM的两种装载器包括：启动类装载器和用户自定义类装载器。启动类装载器是JVM实现的一部分，用户自定义类装载器则是java程序的一部分，必须是ClassLoader类的子类。</p>\n</li>\n<li><p>执行引擎：执行引擎是Java虚拟机核心组成部分之一，输入的是字节码文件，处理过程就是字节码解析的等效过程，输出的是执行结果，对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法。执行引擎所运行的所有字节码指令都是针对当前栈帧进行操作。</p>\n</li>\n<li><p>运行时数据区：主要有方法区、堆、Java栈、PC寄存器、本地方法栈。</p>\n</li>\n</ul>\n<h2 id=\"对运行时数据区进行些补充：\"><a href=\"#对运行时数据区进行些补充：\" class=\"headerlink\" title=\"对运行时数据区进行些补充：\"></a>对运行时数据区进行些补充：</h2><ol>\n<li><p>方法区和堆由所有线程共享</p>\n</li>\n<li><p>Java栈和PC寄存器由线程独享，在新线程的创建的时间里</p>\n</li>\n<li><p>本地方法栈：存储本地方法调用的状态</p>\n</li>\n</ol>\n<h2 id=\"JVM中的数据类型：\"><a href=\"#JVM中的数据类型：\" class=\"headerlink\" title=\"JVM中的数据类型：\"></a>JVM中的数据类型：</h2><p>JVM中的基本数据单元是word，而word的长度由JVM的具体实现者来决定。</p>\n<p><em>数据类型包括基本类型和引用类型：</em></p>\n<ul>\n<li><p>基本数据类型包括：数值类型（除boolean外的所有java基本数据类型），boolean在JVM中使用int来表示，0表示false，其他值均表示true，还有一个returnAddress类型，这个是JVM的内部类型，用来实现finally子句。</p>\n</li>\n<li><p>引用类型包括：数组类型、类类型、接口类型</p>\n</li>\n</ul>\n","excerpt":"<p>说明：这篇文章只是个人对JVM的初步探讨总结，很多概念来自网络，加入部分个人理解，也许个人理解的地方有误，也恳请看到的同学帮忙指出，关于JVM的具体知识可以阅读《深入理解Java虚拟机：JVM高级特性与最佳性能》这本书籍。<br>","more":"</p>\n<hr>\n<h1 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h1><p>JVM是Java Virtual Machine的缩写，中文名为java虚拟机，JVM是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。它与VirtualBox那些虚拟PC机的虚拟机又有点区别，它只设置了4个常用的寄存器，分别为：pc程序计数器，optop操作数寄存器，frame当前执行环境指针和vars当前执行环境中的第一个局部变量指针。</p>\n<p>java语言的一个非常重要的特点是平台无关性，而使用java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入java虚拟机后，java语言在不同平台上运行时就不需要重新编译。Java实用java虚拟机屏蔽了与具体平台的信息，使得java语言编译程序只需生成java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。java虚拟机在执行字节码时，把字节码翻译成具体平台上的机器指令执行。这就是java能够“一次编译，到处运行”的原因。</p>\n<h1 id=\"JRE-JDK-JVM的关系\"><a href=\"#JRE-JDK-JVM的关系\" class=\"headerlink\" title=\"JRE/JDK/JVM的关系\"></a>JRE/JDK/JVM的关系</h1><p>JRE（Java Runtime Environment）：中文名为java运行是环境，也就是java平台。所有的java程序都要在有jre的环境下才能运行。</p>\n<p>JDK（Java Development Kit）：中文名为java开发工具，jdk的工具也是java程序，也需要jre环境才能运行。</p>\n<p>JVM（Java Virtual Machine）：中文名为java虚拟机，这个是jre的一部分。</p>\n<h1 id=\"JVM环境的加载\"><a href=\"#JVM环境的加载\" class=\"headerlink\" title=\"JVM环境的加载\"></a>JVM环境的加载</h1><p>以windows操作系统为例，装入JVM是通过jdk中的Java.exe可执行程序来完成的，具体可以分为四步：</p>\n<ol>\n<li><p>创建JVM装载环境和配置</p>\n</li>\n<li><p>装载JVM.dll</p>\n</li>\n<li><p>初始化JVM.dll并挂到JNIENV（JNI调用接口）实例</p>\n</li>\n<li><p>调用JNIENV实例装载并处理class类</p>\n</li>\n</ol>\n<p>关于这个更详细的信息可以参考这篇文章：<a href=\"http://blog.csdn.net/ye1992/article/details/38228393\">http://blog.csdn.net/ye1992/article/details/38228393</a></p>\n<h1 id=\"JVM的生命周期\"><a href=\"#JVM的生命周期\" class=\"headerlink\" title=\"JVM的生命周期\"></a>JVM的生命周期</h1><p>当一个Java程序启动时，一个JVM实例就产生了，任何存在public static void main(String [] args)方法的类都可以作为JVM实例运行的起点，所以在平时定义一个Class时就要显示告诉JVM类名，这样JVM才能知道是该运行哪个类里面的main方法。</p>\n<p>main()方法是初始线程的起点，任何其它线程均由该线程启动。JVM内部存在两种线程，分别为守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，Java程序也可以标明自己创建的线程是守护线程。</p>\n<p>当程序中的所有非守护线程都终止时，JVM才退出，程序中也可以使用setDaemon(boolean on)方法来设定为守护线程。（Linux中说守护进程，这里为什么说守护线程呢？因为，java是跑在JVM虚拟机上的）。</p>\n<h1 id=\"JVM体系结构\"><a href=\"#JVM体系结构\" class=\"headerlink\" title=\"JVM体系结构\"></a>JVM体系结构</h1><p>JVM内部分成三部分，分别为：类装载器（ClassLoader）子系统、执行引擎和运行时数据区。</p>\n<ul>\n<li><p>类装载器子系统：就是用来装载.class文件的系统。JVM的两种装载器包括：启动类装载器和用户自定义类装载器。启动类装载器是JVM实现的一部分，用户自定义类装载器则是java程序的一部分，必须是ClassLoader类的子类。</p>\n</li>\n<li><p>执行引擎：执行引擎是Java虚拟机核心组成部分之一，输入的是字节码文件，处理过程就是字节码解析的等效过程，输出的是执行结果，对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法。执行引擎所运行的所有字节码指令都是针对当前栈帧进行操作。</p>\n</li>\n<li><p>运行时数据区：主要有方法区、堆、Java栈、PC寄存器、本地方法栈。</p>\n</li>\n</ul>\n<h2 id=\"对运行时数据区进行些补充：\"><a href=\"#对运行时数据区进行些补充：\" class=\"headerlink\" title=\"对运行时数据区进行些补充：\"></a>对运行时数据区进行些补充：</h2><ol>\n<li><p>方法区和堆由所有线程共享</p>\n</li>\n<li><p>Java栈和PC寄存器由线程独享，在新线程的创建的时间里</p>\n</li>\n<li><p>本地方法栈：存储本地方法调用的状态</p>\n</li>\n</ol>\n<h2 id=\"JVM中的数据类型：\"><a href=\"#JVM中的数据类型：\" class=\"headerlink\" title=\"JVM中的数据类型：\"></a>JVM中的数据类型：</h2><p>JVM中的基本数据单元是word，而word的长度由JVM的具体实现者来决定。</p>\n<p><em>数据类型包括基本类型和引用类型：</em></p>\n<ul>\n<li><p>基本数据类型包括：数值类型（除boolean外的所有java基本数据类型），boolean在JVM中使用int来表示，0表示false，其他值均表示true，还有一个returnAddress类型，这个是JVM的内部类型，用来实现finally子句。</p>\n</li>\n<li><p>引用类型包括：数组类型、类类型、接口类型</p>\n</li>\n</ul>"},{"title":"Java集合类总结","date":"2016-03-14T16:00:00.000Z","author":"KevinWu","_content":"\n\n> 这篇文章是对java集合类的个人总结\n\n<!--more-->\n﻿\n\n 先来看看java集合类中的框架结构：\n\n- java.util.Collection[interface]\n\n    - java.util.List[interface]\n\n        - java.util.ArrayList[class]\n\n        - java.util.LinkedList[class]\n\n        - java.util.Vector[class]\n\n            - java.util.Stack[class]\n\n    - java.util.set[interface]\n\n        - java.util.HashSet[class]\n\n        - java.util.SortedSet[interface]\n\n            - java.util.TreeSet[class]\n\n\n- java.util.Map[interface]\n\n    - java.util.SortedMap[interface]\n\n        - java.util.TreeMap[class]\n\n    - java.util.Hashtable[class]\n\n    - java.util.HashMap[class]\n\n        - java.util.LinkedHashMap[class]\n\n        - java.util.WeakHashMap[class]\n\n    - ConcurrentHashMap[class]\n\n\n\n# Collection接口\n\nCollection是最基本的集合类接口，一个Collection代表一组Object，即Collection的元素。一些Collection支持相同的元素，而一些不支持，一些支持排序，java不提供直接继承Collection的类，只提供了继承自Collection的子接口的接口入List和Set。\n\n\n所有集合类都实现了Iterator接口，这是一个遍历集合中的元素的接口，主要包含hasNext()、next()、和remove()三种方法。它的子接口LinkedIterator还在它的基础上加了三种方法：add()、previous()、hasPrevious()。所以只实现了Iterator接口的类，只能往后遍历，被遍历过的元素不会再被遍历到，一般无序的集合都实现了这个接口。而有序的集合一般都实现了LinkedIterator接口，这样可以实现双向遍历，如ArrayList，既可以用next()访问下一个元素，又可以用previous()访问前一个元素。\n\n\n\n需要注意一点是，如果要自己去实现一个集合类，就可以实用java定义好的抽象类，这些抽象类已经为我们提供了许多实现，我们只需要根据需求重写一些方法或添加一些方法就行。\n\n\n\n根据用途的不同，Collection划分为List和Set。\n\n\n\n## List接口\n\nList是继承自Collection的接口。它是有序的，使用这个接口可以精准地控制每个元素插入的位置。可以使用index索引值来访问List中的元素。跟Set不同，List允许有重复的元素。\n\n除了具备Collection接口的Iterator()方法外，List还提供了一个listIterator()方法，返回的是一个ListIterator接口，这个接口与标准Iterator接口相比，多了一些add()之类的方法，允许添加，删除，设定元素，还可以向前，向后遍历。\n\n实现了List接口的常用类有LinkedList，ArrayList，Vector和Stack。\n\n\n\n### LinkedList类\n\nLinkedList类实现了List接口，允许插入null元素。可以把它看成双向链表，可以使用LinkedList实现栈（stack）、队列（queue）或双向队列（deque）。\n\n需要注意的是LinkedList没有同步的方法，如果需要在多个线程中访问LinkedList，就需要注意线程同步的问题，或者在创建List时构造一个同步的List，代码如下：\n\n``` java\nList<Object> list=Collections.synchronizedList(new LinkedList<>());\n```\n\n\n\n### ArrayList类\n\nArrayList可以理解为动态数组。它允许所有的元素，包括null值的元素。ArrayList的初始大小为10，当容量不足时，就会设置成原来的容量的1.5倍加1的新容量，一般确定元素数量的情况下使用ArrayList，否则应该使用LinkedList，因为当容量不足时，都要将原来的元素复制到一个新的数组中，这个操作非常耗时。\n\n同样，ArrayList类也不是同步的，需要注意线程同步问题。\n\n\n\n### Vector类\n\nVector类与ArrayList类非常相似，默认值也是10，当容量不足时，如果制定了incr参数，则增加incr个容量，否则直接在原来容量的基础上加倍。\n\nVector和ArrayList有别的还有一点，就是Vector是线程同步的。\n\n所以，当一个Iterator被创建且正在被使用时，另一个线程试图改变Vector的元素值时，就会抛出ConcurrentModificationException异常。\n\n\n\n#### Stack类\n\nStack类继承自Vector类，也就是说Vector有的方法它都有，而且在这基础上，实现了先进后出的栈。它提供了5个额外的方法使得一个Vector可以当做堆栈使用，5个方法如下：\n\n- push 进栈\n\n- pop 出栈\n\n- peek 得到栈顶的元素\n\n- empty 测试栈是否为空\n\n- search 检测一个元素在堆栈中的位置\n\n\n\n## Set接口\n\nSet和List一样是继承自Collection接口，但与List不同的是，Set是一种不可以包含重复元素的集合。Set类最多只允许有一个null值（有两个null值不就重复了么？～～）。\n\n\n\n### HashSet类\n\n这个类实现了Set接口，它底层是基于HashMap实现的，HashSet的底层使用HashMap来保存所有的元素，在Set里面用的只是Map的key，在HashSet里面判断两个元素是否相等，是通过hasCode()和equal()两个方法共同完成的，如果集合的对象中没有重写者两个方法，就会使用object继承来的方法，即比较地址。\n\n\n\n### SortedSet接口\n\nSortedSet接口里面的元素一定是有序的。这里的有序不是指插入顺序，而是指根据对象的比较顺序。\n\n对于SortedSet这个接口，目前java仅有一个具体实现的类——TreeSet。\n\n\n\n#### TreeSet类\n\nTreeSet类实现Set接口，它是依靠TreeMap实现的，对于TreeSet，需要注意以下几点：\n\n- TreeSet存储对象的时候，可以排序，但是需要指定排序算法。\n\n- Integer可以有默认顺序，String有默认顺序，但是如果是自定义类型，则会出现异常（因为没有默认顺序）\n\n- 如果想把自定义类型存入TreeSet进行排序，那么就需要对该类型实现Comparable接口并重写compareTo()方法，这样在调用add()方法往TreeSet对象添加元素时就会自动调用比较的方法，根据比较的结果使用二叉树的形式存储。\n\n\n\n## Map接口\n\nMap接口没有继承Collection接口。也就是说Map和Collection是两种不同类型的集合。Collection可以看做是value（值）的集合，而Map可以看做是key,value（键值对）的集合。\n\nMap有3种集合视图，分别为一组key集合、一组value集合或者一组key-value映射。\n\n\n\n### SortedMap接口\n\n保证按照键的升序排列的映射，可以按照键的自然顺序进行排序，或者通过创建有序映射时提供的比较器进行排序。\n\n这个接口的一个比较常用的实现类是TreeMap。\n\n\n\n#### TreeMap类\n\nTreeMap类是SortedMap接口的一个具体实现，这个类保证了映射按照升序排序关键字，基于红黑树（自平衡二叉查找树）。根据构造方法的不同，可能按照键值的自然顺序排序，或者按照创建时所提供的比较器进行排序。这个类也是不允许重复值的，和HashMap一样，如果插入重复的元素，后面的元素就会覆盖掉前面的。它的键key不可以为null，但是值可以为null。\n\n\n\n### Hashtable类\n\nHashtable是Map接口的一个具体实现，实现了一个key-value映射的哈希表。Hashtable的key和value都不允许为空。\n\n添加数据时使用put(key,value)，获取一个数据时使用get(key)。\n\n默认容量大小为11，每次扩容，都是将容量变成原来的2倍加1。\n\nHashtable通过initial capacity和load factor两个参数来调整性能。默认的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查找时间将会增大，会影响get和put等操作。\n\nHashtable是线程同步的。\n\n\n\n### HashMap类\n\nHashMap也实现了一个key-value映射的哈希表，存储结构和冲突解决与hashtable一致，但HashMap是允许null值的，即key和value的值都允许为null，其中key为null的键值对永远存放在以table[0]为头节点的链表中，当然不一定是存放在头节点table[0]中。\n\nHashMap的默认大小为16，无论设定容量为多少，构造方法都会将实际容量设为不小于指定容量的2的次方的一个数，这样是为了让hash发生碰撞的概率较小，使元素在哈希表中均匀地散列，且这个数的最大值不能超过2的30次方。\n\n每次加入键值对时，都要判断当前已用的槽的数目是否大于等于【容量*load factor】(load factor默认0.75)，如果大于或等于，就进行扩容，每次扩容，容量都编程原来的两倍。\n\n\n\n##### 补充：Hashtable和HashMap的区别\n\n它们的主要区别在于：线程安全性、同步以及速度\n\n1. HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的和允许空值null。\n\n2. HashMap是非synchronized的，而Hashtable是synchronized的，这意味者Hashtable是线程安全的，多线程可以共享一个Hashtable，如果没有使用同步，多线程不能共享HashMap。\n\n3. 另一个区别是HashMap的迭代器Iterator是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素）时将会抛出ConcurrentModificationException异常。\n\n4. 由于Hashtable是线程安全的，所以在单线程情况下要比HashMap要慢。\n\n5. HashMap不能保证随着时间的推移Map中的元素次序是不变的。\n\n\n\n#### LinkedHashMap类\n\nLinkedHashMap类是HashMap和LinkedList的结合，它的父类是HashMap。它额外定义了一个head为头节点的空的双向循环链表，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，就是说与键值对的插入顺序保持一致。因为要维护插入顺序，所以性能要低于HashMap，但是在迭代访问元素时会有很好的性能，因为它以链表维护内部顺序。\n\n\n\n#### WeakHashMap类\n\nWeakHashMap的用法基本与HashMap相同，区别在于HashMap的key保留对象的强引用，即只要HashMap对象不被销毁，其对象所有key所引用的对象不会被垃圾回收，HashMap也不会自动删除这些key所对应的键值对象。但WeakHashMap的key所引用的对象没有被其他强引用的变量所引用，则这些key所引用的对象可能被回收。WeakHashMap中的每个key对象保存了实际对象的弱引用，当回收了该key所对应的实际对象后，WeakHashMap会自动删除该key对应的键值对。\n\n\n\n### ConcurrentHashMap类\n\nConcurrentHashMap最重要的是引入了Segment的概念，他在自己内部定义了这个Class来管理数据，这个Segment类似与HashMap的定义，ConcurrentHashMap会将对应的读写操作交给Segment。\n\nConcurrentHashMap默认将Map分成16个Segment，分段锁，有16个写线程执行写，而读的大部分时候都不需要用到锁。只有在size等操作时才需要锁住整个哈希表。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Java/201603/Java集合类总结.md","raw":"---\ntitle: Java集合类总结\ndate: 2016-03-15\nauthor:  KevinWu\ncategories: Java\ntags: \n\t- Java \n\t- 集合\n---\n\n\n> 这篇文章是对java集合类的个人总结\n\n<!--more-->\n﻿\n\n 先来看看java集合类中的框架结构：\n\n- java.util.Collection[interface]\n\n    - java.util.List[interface]\n\n        - java.util.ArrayList[class]\n\n        - java.util.LinkedList[class]\n\n        - java.util.Vector[class]\n\n            - java.util.Stack[class]\n\n    - java.util.set[interface]\n\n        - java.util.HashSet[class]\n\n        - java.util.SortedSet[interface]\n\n            - java.util.TreeSet[class]\n\n\n- java.util.Map[interface]\n\n    - java.util.SortedMap[interface]\n\n        - java.util.TreeMap[class]\n\n    - java.util.Hashtable[class]\n\n    - java.util.HashMap[class]\n\n        - java.util.LinkedHashMap[class]\n\n        - java.util.WeakHashMap[class]\n\n    - ConcurrentHashMap[class]\n\n\n\n# Collection接口\n\nCollection是最基本的集合类接口，一个Collection代表一组Object，即Collection的元素。一些Collection支持相同的元素，而一些不支持，一些支持排序，java不提供直接继承Collection的类，只提供了继承自Collection的子接口的接口入List和Set。\n\n\n所有集合类都实现了Iterator接口，这是一个遍历集合中的元素的接口，主要包含hasNext()、next()、和remove()三种方法。它的子接口LinkedIterator还在它的基础上加了三种方法：add()、previous()、hasPrevious()。所以只实现了Iterator接口的类，只能往后遍历，被遍历过的元素不会再被遍历到，一般无序的集合都实现了这个接口。而有序的集合一般都实现了LinkedIterator接口，这样可以实现双向遍历，如ArrayList，既可以用next()访问下一个元素，又可以用previous()访问前一个元素。\n\n\n\n需要注意一点是，如果要自己去实现一个集合类，就可以实用java定义好的抽象类，这些抽象类已经为我们提供了许多实现，我们只需要根据需求重写一些方法或添加一些方法就行。\n\n\n\n根据用途的不同，Collection划分为List和Set。\n\n\n\n## List接口\n\nList是继承自Collection的接口。它是有序的，使用这个接口可以精准地控制每个元素插入的位置。可以使用index索引值来访问List中的元素。跟Set不同，List允许有重复的元素。\n\n除了具备Collection接口的Iterator()方法外，List还提供了一个listIterator()方法，返回的是一个ListIterator接口，这个接口与标准Iterator接口相比，多了一些add()之类的方法，允许添加，删除，设定元素，还可以向前，向后遍历。\n\n实现了List接口的常用类有LinkedList，ArrayList，Vector和Stack。\n\n\n\n### LinkedList类\n\nLinkedList类实现了List接口，允许插入null元素。可以把它看成双向链表，可以使用LinkedList实现栈（stack）、队列（queue）或双向队列（deque）。\n\n需要注意的是LinkedList没有同步的方法，如果需要在多个线程中访问LinkedList，就需要注意线程同步的问题，或者在创建List时构造一个同步的List，代码如下：\n\n``` java\nList<Object> list=Collections.synchronizedList(new LinkedList<>());\n```\n\n\n\n### ArrayList类\n\nArrayList可以理解为动态数组。它允许所有的元素，包括null值的元素。ArrayList的初始大小为10，当容量不足时，就会设置成原来的容量的1.5倍加1的新容量，一般确定元素数量的情况下使用ArrayList，否则应该使用LinkedList，因为当容量不足时，都要将原来的元素复制到一个新的数组中，这个操作非常耗时。\n\n同样，ArrayList类也不是同步的，需要注意线程同步问题。\n\n\n\n### Vector类\n\nVector类与ArrayList类非常相似，默认值也是10，当容量不足时，如果制定了incr参数，则增加incr个容量，否则直接在原来容量的基础上加倍。\n\nVector和ArrayList有别的还有一点，就是Vector是线程同步的。\n\n所以，当一个Iterator被创建且正在被使用时，另一个线程试图改变Vector的元素值时，就会抛出ConcurrentModificationException异常。\n\n\n\n#### Stack类\n\nStack类继承自Vector类，也就是说Vector有的方法它都有，而且在这基础上，实现了先进后出的栈。它提供了5个额外的方法使得一个Vector可以当做堆栈使用，5个方法如下：\n\n- push 进栈\n\n- pop 出栈\n\n- peek 得到栈顶的元素\n\n- empty 测试栈是否为空\n\n- search 检测一个元素在堆栈中的位置\n\n\n\n## Set接口\n\nSet和List一样是继承自Collection接口，但与List不同的是，Set是一种不可以包含重复元素的集合。Set类最多只允许有一个null值（有两个null值不就重复了么？～～）。\n\n\n\n### HashSet类\n\n这个类实现了Set接口，它底层是基于HashMap实现的，HashSet的底层使用HashMap来保存所有的元素，在Set里面用的只是Map的key，在HashSet里面判断两个元素是否相等，是通过hasCode()和equal()两个方法共同完成的，如果集合的对象中没有重写者两个方法，就会使用object继承来的方法，即比较地址。\n\n\n\n### SortedSet接口\n\nSortedSet接口里面的元素一定是有序的。这里的有序不是指插入顺序，而是指根据对象的比较顺序。\n\n对于SortedSet这个接口，目前java仅有一个具体实现的类——TreeSet。\n\n\n\n#### TreeSet类\n\nTreeSet类实现Set接口，它是依靠TreeMap实现的，对于TreeSet，需要注意以下几点：\n\n- TreeSet存储对象的时候，可以排序，但是需要指定排序算法。\n\n- Integer可以有默认顺序，String有默认顺序，但是如果是自定义类型，则会出现异常（因为没有默认顺序）\n\n- 如果想把自定义类型存入TreeSet进行排序，那么就需要对该类型实现Comparable接口并重写compareTo()方法，这样在调用add()方法往TreeSet对象添加元素时就会自动调用比较的方法，根据比较的结果使用二叉树的形式存储。\n\n\n\n## Map接口\n\nMap接口没有继承Collection接口。也就是说Map和Collection是两种不同类型的集合。Collection可以看做是value（值）的集合，而Map可以看做是key,value（键值对）的集合。\n\nMap有3种集合视图，分别为一组key集合、一组value集合或者一组key-value映射。\n\n\n\n### SortedMap接口\n\n保证按照键的升序排列的映射，可以按照键的自然顺序进行排序，或者通过创建有序映射时提供的比较器进行排序。\n\n这个接口的一个比较常用的实现类是TreeMap。\n\n\n\n#### TreeMap类\n\nTreeMap类是SortedMap接口的一个具体实现，这个类保证了映射按照升序排序关键字，基于红黑树（自平衡二叉查找树）。根据构造方法的不同，可能按照键值的自然顺序排序，或者按照创建时所提供的比较器进行排序。这个类也是不允许重复值的，和HashMap一样，如果插入重复的元素，后面的元素就会覆盖掉前面的。它的键key不可以为null，但是值可以为null。\n\n\n\n### Hashtable类\n\nHashtable是Map接口的一个具体实现，实现了一个key-value映射的哈希表。Hashtable的key和value都不允许为空。\n\n添加数据时使用put(key,value)，获取一个数据时使用get(key)。\n\n默认容量大小为11，每次扩容，都是将容量变成原来的2倍加1。\n\nHashtable通过initial capacity和load factor两个参数来调整性能。默认的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查找时间将会增大，会影响get和put等操作。\n\nHashtable是线程同步的。\n\n\n\n### HashMap类\n\nHashMap也实现了一个key-value映射的哈希表，存储结构和冲突解决与hashtable一致，但HashMap是允许null值的，即key和value的值都允许为null，其中key为null的键值对永远存放在以table[0]为头节点的链表中，当然不一定是存放在头节点table[0]中。\n\nHashMap的默认大小为16，无论设定容量为多少，构造方法都会将实际容量设为不小于指定容量的2的次方的一个数，这样是为了让hash发生碰撞的概率较小，使元素在哈希表中均匀地散列，且这个数的最大值不能超过2的30次方。\n\n每次加入键值对时，都要判断当前已用的槽的数目是否大于等于【容量*load factor】(load factor默认0.75)，如果大于或等于，就进行扩容，每次扩容，容量都编程原来的两倍。\n\n\n\n##### 补充：Hashtable和HashMap的区别\n\n它们的主要区别在于：线程安全性、同步以及速度\n\n1. HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的和允许空值null。\n\n2. HashMap是非synchronized的，而Hashtable是synchronized的，这意味者Hashtable是线程安全的，多线程可以共享一个Hashtable，如果没有使用同步，多线程不能共享HashMap。\n\n3. 另一个区别是HashMap的迭代器Iterator是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素）时将会抛出ConcurrentModificationException异常。\n\n4. 由于Hashtable是线程安全的，所以在单线程情况下要比HashMap要慢。\n\n5. HashMap不能保证随着时间的推移Map中的元素次序是不变的。\n\n\n\n#### LinkedHashMap类\n\nLinkedHashMap类是HashMap和LinkedList的结合，它的父类是HashMap。它额外定义了一个head为头节点的空的双向循环链表，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，就是说与键值对的插入顺序保持一致。因为要维护插入顺序，所以性能要低于HashMap，但是在迭代访问元素时会有很好的性能，因为它以链表维护内部顺序。\n\n\n\n#### WeakHashMap类\n\nWeakHashMap的用法基本与HashMap相同，区别在于HashMap的key保留对象的强引用，即只要HashMap对象不被销毁，其对象所有key所引用的对象不会被垃圾回收，HashMap也不会自动删除这些key所对应的键值对象。但WeakHashMap的key所引用的对象没有被其他强引用的变量所引用，则这些key所引用的对象可能被回收。WeakHashMap中的每个key对象保存了实际对象的弱引用，当回收了该key所对应的实际对象后，WeakHashMap会自动删除该key对应的键值对。\n\n\n\n### ConcurrentHashMap类\n\nConcurrentHashMap最重要的是引入了Segment的概念，他在自己内部定义了这个Class来管理数据，这个Segment类似与HashMap的定义，ConcurrentHashMap会将对应的读写操作交给Segment。\n\nConcurrentHashMap默认将Map分成16个Segment，分段锁，有16个写线程执行写，而读的大部分时候都不需要用到锁。只有在size等操作时才需要锁住整个哈希表。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Java/201603/Java集合类总结","published":1,"updated":"2016-03-19T14:32:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinisi4kx00133ntf6y8x1y05","content":"<blockquote>\n<p>这篇文章是对java集合类的个人总结</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>﻿</p>\n<p> 先来看看java集合类中的框架结构：</p>\n<ul>\n<li><p>java.util.Collection[interface]</p>\n<ul>\n<li><p>java.util.List[interface]</p>\n<ul>\n<li><p>java.util.ArrayList[class]</p>\n</li>\n<li><p>java.util.LinkedList[class]</p>\n</li>\n<li><p>java.util.Vector[class]</p>\n<ul>\n<li>java.util.Stack[class]</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>java.util.set[interface]</p>\n<ul>\n<li><p>java.util.HashSet[class]</p>\n</li>\n<li><p>java.util.SortedSet[interface]</p>\n<ul>\n<li>java.util.TreeSet[class]</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>java.util.Map[interface]</p>\n<ul>\n<li><p>java.util.SortedMap[interface]</p>\n<ul>\n<li>java.util.TreeMap[class]</li>\n</ul>\n</li>\n<li><p>java.util.Hashtable[class]</p>\n</li>\n<li><p>java.util.HashMap[class]</p>\n<ul>\n<li><p>java.util.LinkedHashMap[class]</p>\n</li>\n<li><p>java.util.WeakHashMap[class]</p>\n</li>\n</ul>\n</li>\n<li><p>ConcurrentHashMap[class]</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Collection接口\"><a href=\"#Collection接口\" class=\"headerlink\" title=\"Collection接口\"></a>Collection接口</h1><p>Collection是最基本的集合类接口，一个Collection代表一组Object，即Collection的元素。一些Collection支持相同的元素，而一些不支持，一些支持排序，java不提供直接继承Collection的类，只提供了继承自Collection的子接口的接口入List和Set。</p>\n<p>所有集合类都实现了Iterator接口，这是一个遍历集合中的元素的接口，主要包含hasNext()、next()、和remove()三种方法。它的子接口LinkedIterator还在它的基础上加了三种方法：add()、previous()、hasPrevious()。所以只实现了Iterator接口的类，只能往后遍历，被遍历过的元素不会再被遍历到，一般无序的集合都实现了这个接口。而有序的集合一般都实现了LinkedIterator接口，这样可以实现双向遍历，如ArrayList，既可以用next()访问下一个元素，又可以用previous()访问前一个元素。</p>\n<p>需要注意一点是，如果要自己去实现一个集合类，就可以实用java定义好的抽象类，这些抽象类已经为我们提供了许多实现，我们只需要根据需求重写一些方法或添加一些方法就行。</p>\n<p>根据用途的不同，Collection划分为List和Set。</p>\n<h2 id=\"List接口\"><a href=\"#List接口\" class=\"headerlink\" title=\"List接口\"></a>List接口</h2><p>List是继承自Collection的接口。它是有序的，使用这个接口可以精准地控制每个元素插入的位置。可以使用index索引值来访问List中的元素。跟Set不同，List允许有重复的元素。</p>\n<p>除了具备Collection接口的Iterator()方法外，List还提供了一个listIterator()方法，返回的是一个ListIterator接口，这个接口与标准Iterator接口相比，多了一些add()之类的方法，允许添加，删除，设定元素，还可以向前，向后遍历。</p>\n<p>实现了List接口的常用类有LinkedList，ArrayList，Vector和Stack。</p>\n<h3 id=\"LinkedList类\"><a href=\"#LinkedList类\" class=\"headerlink\" title=\"LinkedList类\"></a>LinkedList类</h3><p>LinkedList类实现了List接口，允许插入null元素。可以把它看成双向链表，可以使用LinkedList实现栈（stack）、队列（queue）或双向队列（deque）。</p>\n<p>需要注意的是LinkedList没有同步的方法，如果需要在多个线程中访问LinkedList，就需要注意线程同步的问题，或者在创建List时构造一个同步的List，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Object&gt; list=Collections.synchronizedList(<span class=\"keyword\">new</span> LinkedList&lt;&gt;());</span><br></pre></td></tr></table></figure>\n<h3 id=\"ArrayList类\"><a href=\"#ArrayList类\" class=\"headerlink\" title=\"ArrayList类\"></a>ArrayList类</h3><p>ArrayList可以理解为动态数组。它允许所有的元素，包括null值的元素。ArrayList的初始大小为10，当容量不足时，就会设置成原来的容量的1.5倍加1的新容量，一般确定元素数量的情况下使用ArrayList，否则应该使用LinkedList，因为当容量不足时，都要将原来的元素复制到一个新的数组中，这个操作非常耗时。</p>\n<p>同样，ArrayList类也不是同步的，需要注意线程同步问题。</p>\n<h3 id=\"Vector类\"><a href=\"#Vector类\" class=\"headerlink\" title=\"Vector类\"></a>Vector类</h3><p>Vector类与ArrayList类非常相似，默认值也是10，当容量不足时，如果制定了incr参数，则增加incr个容量，否则直接在原来容量的基础上加倍。</p>\n<p>Vector和ArrayList有别的还有一点，就是Vector是线程同步的。</p>\n<p>所以，当一个Iterator被创建且正在被使用时，另一个线程试图改变Vector的元素值时，就会抛出ConcurrentModificationException异常。</p>\n<h4 id=\"Stack类\"><a href=\"#Stack类\" class=\"headerlink\" title=\"Stack类\"></a>Stack类</h4><p>Stack类继承自Vector类，也就是说Vector有的方法它都有，而且在这基础上，实现了先进后出的栈。它提供了5个额外的方法使得一个Vector可以当做堆栈使用，5个方法如下：</p>\n<ul>\n<li><p>push 进栈</p>\n</li>\n<li><p>pop 出栈</p>\n</li>\n<li><p>peek 得到栈顶的元素</p>\n</li>\n<li><p>empty 测试栈是否为空</p>\n</li>\n<li><p>search 检测一个元素在堆栈中的位置</p>\n</li>\n</ul>\n<h2 id=\"Set接口\"><a href=\"#Set接口\" class=\"headerlink\" title=\"Set接口\"></a>Set接口</h2><p>Set和List一样是继承自Collection接口，但与List不同的是，Set是一种不可以包含重复元素的集合。Set类最多只允许有一个null值（有两个null值不就重复了么？～～）。</p>\n<h3 id=\"HashSet类\"><a href=\"#HashSet类\" class=\"headerlink\" title=\"HashSet类\"></a>HashSet类</h3><p>这个类实现了Set接口，它底层是基于HashMap实现的，HashSet的底层使用HashMap来保存所有的元素，在Set里面用的只是Map的key，在HashSet里面判断两个元素是否相等，是通过hasCode()和equal()两个方法共同完成的，如果集合的对象中没有重写者两个方法，就会使用object继承来的方法，即比较地址。</p>\n<h3 id=\"SortedSet接口\"><a href=\"#SortedSet接口\" class=\"headerlink\" title=\"SortedSet接口\"></a>SortedSet接口</h3><p>SortedSet接口里面的元素一定是有序的。这里的有序不是指插入顺序，而是指根据对象的比较顺序。</p>\n<p>对于SortedSet这个接口，目前java仅有一个具体实现的类——TreeSet。</p>\n<h4 id=\"TreeSet类\"><a href=\"#TreeSet类\" class=\"headerlink\" title=\"TreeSet类\"></a>TreeSet类</h4><p>TreeSet类实现Set接口，它是依靠TreeMap实现的，对于TreeSet，需要注意以下几点：</p>\n<ul>\n<li><p>TreeSet存储对象的时候，可以排序，但是需要指定排序算法。</p>\n</li>\n<li><p>Integer可以有默认顺序，String有默认顺序，但是如果是自定义类型，则会出现异常（因为没有默认顺序）</p>\n</li>\n<li><p>如果想把自定义类型存入TreeSet进行排序，那么就需要对该类型实现Comparable接口并重写compareTo()方法，这样在调用add()方法往TreeSet对象添加元素时就会自动调用比较的方法，根据比较的结果使用二叉树的形式存储。</p>\n</li>\n</ul>\n<h2 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h2><p>Map接口没有继承Collection接口。也就是说Map和Collection是两种不同类型的集合。Collection可以看做是value（值）的集合，而Map可以看做是key,value（键值对）的集合。</p>\n<p>Map有3种集合视图，分别为一组key集合、一组value集合或者一组key-value映射。</p>\n<h3 id=\"SortedMap接口\"><a href=\"#SortedMap接口\" class=\"headerlink\" title=\"SortedMap接口\"></a>SortedMap接口</h3><p>保证按照键的升序排列的映射，可以按照键的自然顺序进行排序，或者通过创建有序映射时提供的比较器进行排序。</p>\n<p>这个接口的一个比较常用的实现类是TreeMap。</p>\n<h4 id=\"TreeMap类\"><a href=\"#TreeMap类\" class=\"headerlink\" title=\"TreeMap类\"></a>TreeMap类</h4><p>TreeMap类是SortedMap接口的一个具体实现，这个类保证了映射按照升序排序关键字，基于红黑树（自平衡二叉查找树）。根据构造方法的不同，可能按照键值的自然顺序排序，或者按照创建时所提供的比较器进行排序。这个类也是不允许重复值的，和HashMap一样，如果插入重复的元素，后面的元素就会覆盖掉前面的。它的键key不可以为null，但是值可以为null。</p>\n<h3 id=\"Hashtable类\"><a href=\"#Hashtable类\" class=\"headerlink\" title=\"Hashtable类\"></a>Hashtable类</h3><p>Hashtable是Map接口的一个具体实现，实现了一个key-value映射的哈希表。Hashtable的key和value都不允许为空。</p>\n<p>添加数据时使用put(key,value)，获取一个数据时使用get(key)。</p>\n<p>默认容量大小为11，每次扩容，都是将容量变成原来的2倍加1。</p>\n<p>Hashtable通过initial capacity和load factor两个参数来调整性能。默认的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查找时间将会增大，会影响get和put等操作。</p>\n<p>Hashtable是线程同步的。</p>\n<h3 id=\"HashMap类\"><a href=\"#HashMap类\" class=\"headerlink\" title=\"HashMap类\"></a>HashMap类</h3><p>HashMap也实现了一个key-value映射的哈希表，存储结构和冲突解决与hashtable一致，但HashMap是允许null值的，即key和value的值都允许为null，其中key为null的键值对永远存放在以table[0]为头节点的链表中，当然不一定是存放在头节点table[0]中。</p>\n<p>HashMap的默认大小为16，无论设定容量为多少，构造方法都会将实际容量设为不小于指定容量的2的次方的一个数，这样是为了让hash发生碰撞的概率较小，使元素在哈希表中均匀地散列，且这个数的最大值不能超过2的30次方。</p>\n<p>每次加入键值对时，都要判断当前已用的槽的数目是否大于等于【容量*load factor】(load factor默认0.75)，如果大于或等于，就进行扩容，每次扩容，容量都编程原来的两倍。</p>\n<h5 id=\"补充：Hashtable和HashMap的区别\"><a href=\"#补充：Hashtable和HashMap的区别\" class=\"headerlink\" title=\"补充：Hashtable和HashMap的区别\"></a>补充：Hashtable和HashMap的区别</h5><p>它们的主要区别在于：线程安全性、同步以及速度</p>\n<ol>\n<li><p>HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的和允许空值null。</p>\n</li>\n<li><p>HashMap是非synchronized的，而Hashtable是synchronized的，这意味者Hashtable是线程安全的，多线程可以共享一个Hashtable，如果没有使用同步，多线程不能共享HashMap。</p>\n</li>\n<li><p>另一个区别是HashMap的迭代器Iterator是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素）时将会抛出ConcurrentModificationException异常。</p>\n</li>\n<li><p>由于Hashtable是线程安全的，所以在单线程情况下要比HashMap要慢。</p>\n</li>\n<li><p>HashMap不能保证随着时间的推移Map中的元素次序是不变的。</p>\n</li>\n</ol>\n<h4 id=\"LinkedHashMap类\"><a href=\"#LinkedHashMap类\" class=\"headerlink\" title=\"LinkedHashMap类\"></a>LinkedHashMap类</h4><p>LinkedHashMap类是HashMap和LinkedList的结合，它的父类是HashMap。它额外定义了一个head为头节点的空的双向循环链表，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，就是说与键值对的插入顺序保持一致。因为要维护插入顺序，所以性能要低于HashMap，但是在迭代访问元素时会有很好的性能，因为它以链表维护内部顺序。</p>\n<h4 id=\"WeakHashMap类\"><a href=\"#WeakHashMap类\" class=\"headerlink\" title=\"WeakHashMap类\"></a>WeakHashMap类</h4><p>WeakHashMap的用法基本与HashMap相同，区别在于HashMap的key保留对象的强引用，即只要HashMap对象不被销毁，其对象所有key所引用的对象不会被垃圾回收，HashMap也不会自动删除这些key所对应的键值对象。但WeakHashMap的key所引用的对象没有被其他强引用的变量所引用，则这些key所引用的对象可能被回收。WeakHashMap中的每个key对象保存了实际对象的弱引用，当回收了该key所对应的实际对象后，WeakHashMap会自动删除该key对应的键值对。</p>\n<h3 id=\"ConcurrentHashMap类\"><a href=\"#ConcurrentHashMap类\" class=\"headerlink\" title=\"ConcurrentHashMap类\"></a>ConcurrentHashMap类</h3><p>ConcurrentHashMap最重要的是引入了Segment的概念，他在自己内部定义了这个Class来管理数据，这个Segment类似与HashMap的定义，ConcurrentHashMap会将对应的读写操作交给Segment。</p>\n<p>ConcurrentHashMap默认将Map分成16个Segment，分段锁，有16个写线程执行写，而读的大部分时候都不需要用到锁。只有在size等操作时才需要锁住整个哈希表。</p>\n","excerpt":"<blockquote>\n<p>这篇文章是对java集合类的个人总结</p>\n</blockquote>","more":"<p>﻿</p>\n<p> 先来看看java集合类中的框架结构：</p>\n<ul>\n<li><p>java.util.Collection[interface]</p>\n<ul>\n<li><p>java.util.List[interface]</p>\n<ul>\n<li><p>java.util.ArrayList[class]</p>\n</li>\n<li><p>java.util.LinkedList[class]</p>\n</li>\n<li><p>java.util.Vector[class]</p>\n<ul>\n<li>java.util.Stack[class]</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>java.util.set[interface]</p>\n<ul>\n<li><p>java.util.HashSet[class]</p>\n</li>\n<li><p>java.util.SortedSet[interface]</p>\n<ul>\n<li>java.util.TreeSet[class]</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>java.util.Map[interface]</p>\n<ul>\n<li><p>java.util.SortedMap[interface]</p>\n<ul>\n<li>java.util.TreeMap[class]</li>\n</ul>\n</li>\n<li><p>java.util.Hashtable[class]</p>\n</li>\n<li><p>java.util.HashMap[class]</p>\n<ul>\n<li><p>java.util.LinkedHashMap[class]</p>\n</li>\n<li><p>java.util.WeakHashMap[class]</p>\n</li>\n</ul>\n</li>\n<li><p>ConcurrentHashMap[class]</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Collection接口\"><a href=\"#Collection接口\" class=\"headerlink\" title=\"Collection接口\"></a>Collection接口</h1><p>Collection是最基本的集合类接口，一个Collection代表一组Object，即Collection的元素。一些Collection支持相同的元素，而一些不支持，一些支持排序，java不提供直接继承Collection的类，只提供了继承自Collection的子接口的接口入List和Set。</p>\n<p>所有集合类都实现了Iterator接口，这是一个遍历集合中的元素的接口，主要包含hasNext()、next()、和remove()三种方法。它的子接口LinkedIterator还在它的基础上加了三种方法：add()、previous()、hasPrevious()。所以只实现了Iterator接口的类，只能往后遍历，被遍历过的元素不会再被遍历到，一般无序的集合都实现了这个接口。而有序的集合一般都实现了LinkedIterator接口，这样可以实现双向遍历，如ArrayList，既可以用next()访问下一个元素，又可以用previous()访问前一个元素。</p>\n<p>需要注意一点是，如果要自己去实现一个集合类，就可以实用java定义好的抽象类，这些抽象类已经为我们提供了许多实现，我们只需要根据需求重写一些方法或添加一些方法就行。</p>\n<p>根据用途的不同，Collection划分为List和Set。</p>\n<h2 id=\"List接口\"><a href=\"#List接口\" class=\"headerlink\" title=\"List接口\"></a>List接口</h2><p>List是继承自Collection的接口。它是有序的，使用这个接口可以精准地控制每个元素插入的位置。可以使用index索引值来访问List中的元素。跟Set不同，List允许有重复的元素。</p>\n<p>除了具备Collection接口的Iterator()方法外，List还提供了一个listIterator()方法，返回的是一个ListIterator接口，这个接口与标准Iterator接口相比，多了一些add()之类的方法，允许添加，删除，设定元素，还可以向前，向后遍历。</p>\n<p>实现了List接口的常用类有LinkedList，ArrayList，Vector和Stack。</p>\n<h3 id=\"LinkedList类\"><a href=\"#LinkedList类\" class=\"headerlink\" title=\"LinkedList类\"></a>LinkedList类</h3><p>LinkedList类实现了List接口，允许插入null元素。可以把它看成双向链表，可以使用LinkedList实现栈（stack）、队列（queue）或双向队列（deque）。</p>\n<p>需要注意的是LinkedList没有同步的方法，如果需要在多个线程中访问LinkedList，就需要注意线程同步的问题，或者在创建List时构造一个同步的List，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Object&gt; list=Collections.synchronizedList(<span class=\"keyword\">new</span> LinkedList&lt;&gt;());</span><br></pre></td></tr></table></figure>\n<h3 id=\"ArrayList类\"><a href=\"#ArrayList类\" class=\"headerlink\" title=\"ArrayList类\"></a>ArrayList类</h3><p>ArrayList可以理解为动态数组。它允许所有的元素，包括null值的元素。ArrayList的初始大小为10，当容量不足时，就会设置成原来的容量的1.5倍加1的新容量，一般确定元素数量的情况下使用ArrayList，否则应该使用LinkedList，因为当容量不足时，都要将原来的元素复制到一个新的数组中，这个操作非常耗时。</p>\n<p>同样，ArrayList类也不是同步的，需要注意线程同步问题。</p>\n<h3 id=\"Vector类\"><a href=\"#Vector类\" class=\"headerlink\" title=\"Vector类\"></a>Vector类</h3><p>Vector类与ArrayList类非常相似，默认值也是10，当容量不足时，如果制定了incr参数，则增加incr个容量，否则直接在原来容量的基础上加倍。</p>\n<p>Vector和ArrayList有别的还有一点，就是Vector是线程同步的。</p>\n<p>所以，当一个Iterator被创建且正在被使用时，另一个线程试图改变Vector的元素值时，就会抛出ConcurrentModificationException异常。</p>\n<h4 id=\"Stack类\"><a href=\"#Stack类\" class=\"headerlink\" title=\"Stack类\"></a>Stack类</h4><p>Stack类继承自Vector类，也就是说Vector有的方法它都有，而且在这基础上，实现了先进后出的栈。它提供了5个额外的方法使得一个Vector可以当做堆栈使用，5个方法如下：</p>\n<ul>\n<li><p>push 进栈</p>\n</li>\n<li><p>pop 出栈</p>\n</li>\n<li><p>peek 得到栈顶的元素</p>\n</li>\n<li><p>empty 测试栈是否为空</p>\n</li>\n<li><p>search 检测一个元素在堆栈中的位置</p>\n</li>\n</ul>\n<h2 id=\"Set接口\"><a href=\"#Set接口\" class=\"headerlink\" title=\"Set接口\"></a>Set接口</h2><p>Set和List一样是继承自Collection接口，但与List不同的是，Set是一种不可以包含重复元素的集合。Set类最多只允许有一个null值（有两个null值不就重复了么？～～）。</p>\n<h3 id=\"HashSet类\"><a href=\"#HashSet类\" class=\"headerlink\" title=\"HashSet类\"></a>HashSet类</h3><p>这个类实现了Set接口，它底层是基于HashMap实现的，HashSet的底层使用HashMap来保存所有的元素，在Set里面用的只是Map的key，在HashSet里面判断两个元素是否相等，是通过hasCode()和equal()两个方法共同完成的，如果集合的对象中没有重写者两个方法，就会使用object继承来的方法，即比较地址。</p>\n<h3 id=\"SortedSet接口\"><a href=\"#SortedSet接口\" class=\"headerlink\" title=\"SortedSet接口\"></a>SortedSet接口</h3><p>SortedSet接口里面的元素一定是有序的。这里的有序不是指插入顺序，而是指根据对象的比较顺序。</p>\n<p>对于SortedSet这个接口，目前java仅有一个具体实现的类——TreeSet。</p>\n<h4 id=\"TreeSet类\"><a href=\"#TreeSet类\" class=\"headerlink\" title=\"TreeSet类\"></a>TreeSet类</h4><p>TreeSet类实现Set接口，它是依靠TreeMap实现的，对于TreeSet，需要注意以下几点：</p>\n<ul>\n<li><p>TreeSet存储对象的时候，可以排序，但是需要指定排序算法。</p>\n</li>\n<li><p>Integer可以有默认顺序，String有默认顺序，但是如果是自定义类型，则会出现异常（因为没有默认顺序）</p>\n</li>\n<li><p>如果想把自定义类型存入TreeSet进行排序，那么就需要对该类型实现Comparable接口并重写compareTo()方法，这样在调用add()方法往TreeSet对象添加元素时就会自动调用比较的方法，根据比较的结果使用二叉树的形式存储。</p>\n</li>\n</ul>\n<h2 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h2><p>Map接口没有继承Collection接口。也就是说Map和Collection是两种不同类型的集合。Collection可以看做是value（值）的集合，而Map可以看做是key,value（键值对）的集合。</p>\n<p>Map有3种集合视图，分别为一组key集合、一组value集合或者一组key-value映射。</p>\n<h3 id=\"SortedMap接口\"><a href=\"#SortedMap接口\" class=\"headerlink\" title=\"SortedMap接口\"></a>SortedMap接口</h3><p>保证按照键的升序排列的映射，可以按照键的自然顺序进行排序，或者通过创建有序映射时提供的比较器进行排序。</p>\n<p>这个接口的一个比较常用的实现类是TreeMap。</p>\n<h4 id=\"TreeMap类\"><a href=\"#TreeMap类\" class=\"headerlink\" title=\"TreeMap类\"></a>TreeMap类</h4><p>TreeMap类是SortedMap接口的一个具体实现，这个类保证了映射按照升序排序关键字，基于红黑树（自平衡二叉查找树）。根据构造方法的不同，可能按照键值的自然顺序排序，或者按照创建时所提供的比较器进行排序。这个类也是不允许重复值的，和HashMap一样，如果插入重复的元素，后面的元素就会覆盖掉前面的。它的键key不可以为null，但是值可以为null。</p>\n<h3 id=\"Hashtable类\"><a href=\"#Hashtable类\" class=\"headerlink\" title=\"Hashtable类\"></a>Hashtable类</h3><p>Hashtable是Map接口的一个具体实现，实现了一个key-value映射的哈希表。Hashtable的key和value都不允许为空。</p>\n<p>添加数据时使用put(key,value)，获取一个数据时使用get(key)。</p>\n<p>默认容量大小为11，每次扩容，都是将容量变成原来的2倍加1。</p>\n<p>Hashtable通过initial capacity和load factor两个参数来调整性能。默认的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查找时间将会增大，会影响get和put等操作。</p>\n<p>Hashtable是线程同步的。</p>\n<h3 id=\"HashMap类\"><a href=\"#HashMap类\" class=\"headerlink\" title=\"HashMap类\"></a>HashMap类</h3><p>HashMap也实现了一个key-value映射的哈希表，存储结构和冲突解决与hashtable一致，但HashMap是允许null值的，即key和value的值都允许为null，其中key为null的键值对永远存放在以table[0]为头节点的链表中，当然不一定是存放在头节点table[0]中。</p>\n<p>HashMap的默认大小为16，无论设定容量为多少，构造方法都会将实际容量设为不小于指定容量的2的次方的一个数，这样是为了让hash发生碰撞的概率较小，使元素在哈希表中均匀地散列，且这个数的最大值不能超过2的30次方。</p>\n<p>每次加入键值对时，都要判断当前已用的槽的数目是否大于等于【容量*load factor】(load factor默认0.75)，如果大于或等于，就进行扩容，每次扩容，容量都编程原来的两倍。</p>\n<h5 id=\"补充：Hashtable和HashMap的区别\"><a href=\"#补充：Hashtable和HashMap的区别\" class=\"headerlink\" title=\"补充：Hashtable和HashMap的区别\"></a>补充：Hashtable和HashMap的区别</h5><p>它们的主要区别在于：线程安全性、同步以及速度</p>\n<ol>\n<li><p>HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的和允许空值null。</p>\n</li>\n<li><p>HashMap是非synchronized的，而Hashtable是synchronized的，这意味者Hashtable是线程安全的，多线程可以共享一个Hashtable，如果没有使用同步，多线程不能共享HashMap。</p>\n</li>\n<li><p>另一个区别是HashMap的迭代器Iterator是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素）时将会抛出ConcurrentModificationException异常。</p>\n</li>\n<li><p>由于Hashtable是线程安全的，所以在单线程情况下要比HashMap要慢。</p>\n</li>\n<li><p>HashMap不能保证随着时间的推移Map中的元素次序是不变的。</p>\n</li>\n</ol>\n<h4 id=\"LinkedHashMap类\"><a href=\"#LinkedHashMap类\" class=\"headerlink\" title=\"LinkedHashMap类\"></a>LinkedHashMap类</h4><p>LinkedHashMap类是HashMap和LinkedList的结合，它的父类是HashMap。它额外定义了一个head为头节点的空的双向循环链表，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，就是说与键值对的插入顺序保持一致。因为要维护插入顺序，所以性能要低于HashMap，但是在迭代访问元素时会有很好的性能，因为它以链表维护内部顺序。</p>\n<h4 id=\"WeakHashMap类\"><a href=\"#WeakHashMap类\" class=\"headerlink\" title=\"WeakHashMap类\"></a>WeakHashMap类</h4><p>WeakHashMap的用法基本与HashMap相同，区别在于HashMap的key保留对象的强引用，即只要HashMap对象不被销毁，其对象所有key所引用的对象不会被垃圾回收，HashMap也不会自动删除这些key所对应的键值对象。但WeakHashMap的key所引用的对象没有被其他强引用的变量所引用，则这些key所引用的对象可能被回收。WeakHashMap中的每个key对象保存了实际对象的弱引用，当回收了该key所对应的实际对象后，WeakHashMap会自动删除该key对应的键值对。</p>\n<h3 id=\"ConcurrentHashMap类\"><a href=\"#ConcurrentHashMap类\" class=\"headerlink\" title=\"ConcurrentHashMap类\"></a>ConcurrentHashMap类</h3><p>ConcurrentHashMap最重要的是引入了Segment的概念，他在自己内部定义了这个Class来管理数据，这个Segment类似与HashMap的定义，ConcurrentHashMap会将对应的读写操作交给Segment。</p>\n<p>ConcurrentHashMap默认将Map分成16个Segment，分段锁，有16个写线程执行写，而读的大部分时候都不需要用到锁。只有在size等操作时才需要锁住整个哈希表。</p>"},{"title":"二维数组中的查找——解题及多次优化思路分析","date":"2016-03-26T12:01:24.000Z","_content":"来自《剑指Offer》的一道题。\n## 题目描述：\n在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 \n### 输入描述:\narray： 待查找的二维数组\ntarget：查找的数字\n<!--more-->\n\n### 输出描述:\n查找到返回true，查找不到返回false\n\n---\n### 第一次写的代码\n``` java\npublic class Solution {\n    public boolean Find(int [][] array,int target) {\n        for(int i=0;i<array.length;i++){\n            for(int j=array[i].length-1;j>=0&&array[i][j]>=target;j--){\n                if(array[i][j]==target)return true;\n            }\n        }\n        return false;\n    }\n}\n```\n## 思路分析：\n因为是二维数组，而且是每一行从左到有递增的，所以可以先从大的找起，即每行的最右边，所以逐行遍历下来，比较最右边的元素，比查找的target大则说明在那一行里面，再往回遍历那一行，遍历到就返回true，否则遍历完后没遍历到就返回false。\n由于用了两个循环，所以。。。\n在线编译后结果是：运行时间： 183 ms 占用内存：5075K\n虽然AC了，但是时空非常不可观，于是，优化下看看。\n\n---\n\n### 第二次写的代码\n``` java\npublic class Solution {\n    public boolean Find(int [][] array,int target) {\n        if(array.length==0)return false;\n        int divBig=0;\n        for(int i=array.length-1;i>=0;i--){\n            if(array[i].length>0){\n                if(array[i][array[i].length-1]>=target){\n                    for(int j=array[i].length-1;j>=divBig;j--){\n                        if(array[i][j]==target)return true;\n                        if(array[i][j]<target)divBig=j;\n                    }\n                }   \n            }\n        }\n        return false;\n    }\n}\n```\n## 思路分析：\n这次换了一种方式，先从右下角找起，也是逐行遍历，不过这次利用了题目说的这句话**每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。** 优化了一下行遍历，因为列也是递增的，如果往回搜索找到列上元素比目标元素还小时，就说明在当前列的上面所有行对应的列对应的元素肯定比目标元素小，以后就不用继续遍历那些行对应的前面的列了，这样优化一下，果然时间快了一点点，不过也就一点点啊。\n因为还是用了两个循环，时间为O（n^2）量级。\n编译结果：运行时间： 126 ms 占用内存：5019K\n\n---\n\n### 第三次写的代码：\n``` java\npublic class Solution {\n    public boolean Find(int [][] array,int target) {\n        int col=0;//列\n        int row=array.length-1;//行\n        while(row>=0&&col<array[row].length){\n            if(array[row][col]>target)row--;\n            else if(array[row][col]==target)return true;\n            else col++;\n        }\n        return false;\n    }\n}\n```\n这次沿用了上面的思想，但是从左下角找起，换用了一层循环，速度。。。\n貌似快了1ms。。而已。\n编译结果：运行时间： 125 ms 占用内存：5145K\n","source":"_posts/在线刷题/201603/二维数组中的查找——解题及多次优化思路分析.md","raw":"---\ntitle: 二维数组中的查找——解题及多次优化思路分析\ndate: 2016-03-26 20:01:24\ntags: \n- 查找 \n- 二维数组\ncategories: 在线刷题\n---\n来自《剑指Offer》的一道题。\n## 题目描述：\n在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 \n### 输入描述:\narray： 待查找的二维数组\ntarget：查找的数字\n<!--more-->\n\n### 输出描述:\n查找到返回true，查找不到返回false\n\n---\n### 第一次写的代码\n``` java\npublic class Solution {\n    public boolean Find(int [][] array,int target) {\n        for(int i=0;i<array.length;i++){\n            for(int j=array[i].length-1;j>=0&&array[i][j]>=target;j--){\n                if(array[i][j]==target)return true;\n            }\n        }\n        return false;\n    }\n}\n```\n## 思路分析：\n因为是二维数组，而且是每一行从左到有递增的，所以可以先从大的找起，即每行的最右边，所以逐行遍历下来，比较最右边的元素，比查找的target大则说明在那一行里面，再往回遍历那一行，遍历到就返回true，否则遍历完后没遍历到就返回false。\n由于用了两个循环，所以。。。\n在线编译后结果是：运行时间： 183 ms 占用内存：5075K\n虽然AC了，但是时空非常不可观，于是，优化下看看。\n\n---\n\n### 第二次写的代码\n``` java\npublic class Solution {\n    public boolean Find(int [][] array,int target) {\n        if(array.length==0)return false;\n        int divBig=0;\n        for(int i=array.length-1;i>=0;i--){\n            if(array[i].length>0){\n                if(array[i][array[i].length-1]>=target){\n                    for(int j=array[i].length-1;j>=divBig;j--){\n                        if(array[i][j]==target)return true;\n                        if(array[i][j]<target)divBig=j;\n                    }\n                }   \n            }\n        }\n        return false;\n    }\n}\n```\n## 思路分析：\n这次换了一种方式，先从右下角找起，也是逐行遍历，不过这次利用了题目说的这句话**每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。** 优化了一下行遍历，因为列也是递增的，如果往回搜索找到列上元素比目标元素还小时，就说明在当前列的上面所有行对应的列对应的元素肯定比目标元素小，以后就不用继续遍历那些行对应的前面的列了，这样优化一下，果然时间快了一点点，不过也就一点点啊。\n因为还是用了两个循环，时间为O（n^2）量级。\n编译结果：运行时间： 126 ms 占用内存：5019K\n\n---\n\n### 第三次写的代码：\n``` java\npublic class Solution {\n    public boolean Find(int [][] array,int target) {\n        int col=0;//列\n        int row=array.length-1;//行\n        while(row>=0&&col<array[row].length){\n            if(array[row][col]>target)row--;\n            else if(array[row][col]==target)return true;\n            else col++;\n        }\n        return false;\n    }\n}\n```\n这次沿用了上面的思想，但是从左下角找起，换用了一层循环，速度。。。\n貌似快了1ms。。而已。\n编译结果：运行时间： 125 ms 占用内存：5145K\n","slug":"在线刷题/201603/二维数组中的查找——解题及多次优化思路分析","published":1,"updated":"2016-03-26T13:36:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinisi4l200183ntfggk276ai","content":"<p>来自《剑指Offer》的一道题。</p>\n<h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 </p>\n<h3 id=\"输入描述\"><a href=\"#输入描述\" class=\"headerlink\" title=\"输入描述:\"></a>输入描述:</h3><p>array： 待查找的二维数组<br>target：查找的数字<br><a id=\"more\"></a></p>\n<h3 id=\"输出描述\"><a href=\"#输出描述\" class=\"headerlink\" title=\"输出描述:\"></a>输出描述:</h3><p>查找到返回true，查找不到返回false</p>\n<hr>\n<h3 id=\"第一次写的代码\"><a href=\"#第一次写的代码\" class=\"headerlink\" title=\"第一次写的代码\"></a>第一次写的代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> [][] array,<span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;array.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=array[i].length-<span class=\"number\">1</span>;j&gt;=<span class=\"number\">0</span>&amp;&amp;array[i][j]&gt;=target;j--)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(array[i][j]==target)<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路分析：\"><a href=\"#思路分析：\" class=\"headerlink\" title=\"思路分析：\"></a>思路分析：</h2><p>因为是二维数组，而且是每一行从左到有递增的，所以可以先从大的找起，即每行的最右边，所以逐行遍历下来，比较最右边的元素，比查找的target大则说明在那一行里面，再往回遍历那一行，遍历到就返回true，否则遍历完后没遍历到就返回false。<br>由于用了两个循环，所以。。。<br>在线编译后结果是：运行时间： 183 ms 占用内存：5075K<br>虽然AC了，但是时空非常不可观，于是，优化下看看。</p>\n<hr>\n<h3 id=\"第二次写的代码\"><a href=\"#第二次写的代码\" class=\"headerlink\" title=\"第二次写的代码\"></a>第二次写的代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> [][] array,<span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(array.length==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> divBig=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=array.length-<span class=\"number\">1</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(array[i].length&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(array[i][array[i].length-<span class=\"number\">1</span>]&gt;=target)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=array[i].length-<span class=\"number\">1</span>;j&gt;=divBig;j--)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(array[i][j]==target)<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(array[i][j]&lt;target)divBig=j;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;   </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路分析：-1\"><a href=\"#思路分析：-1\" class=\"headerlink\" title=\"思路分析：\"></a>思路分析：</h2><p>这次换了一种方式，先从右下角找起，也是逐行遍历，不过这次利用了题目说的这句话<strong>每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</strong> 优化了一下行遍历，因为列也是递增的，如果往回搜索找到列上元素比目标元素还小时，就说明在当前列的上面所有行对应的列对应的元素肯定比目标元素小，以后就不用继续遍历那些行对应的前面的列了，这样优化一下，果然时间快了一点点，不过也就一点点啊。<br>因为还是用了两个循环，时间为O（n^2）量级。<br>编译结果：运行时间： 126 ms 占用内存：5019K</p>\n<hr>\n<h3 id=\"第三次写的代码：\"><a href=\"#第三次写的代码：\" class=\"headerlink\" title=\"第三次写的代码：\"></a>第三次写的代码：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> [][] array,<span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> col=<span class=\"number\">0</span>;<span class=\"comment\">//列</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> row=array.length-<span class=\"number\">1</span>;<span class=\"comment\">//行</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(row&gt;=<span class=\"number\">0</span>&amp;&amp;col&lt;array[row].length)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(array[row][col]&gt;target)row--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(array[row][col]==target)<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> col++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这次沿用了上面的思想，但是从左下角找起，换用了一层循环，速度。。。<br>貌似快了1ms。。而已。<br>编译结果：运行时间： 125 ms 占用内存：5145K</p>\n","excerpt":"<p>来自《剑指Offer》的一道题。</p>\n<h2 id=\"题目描述：\"><a href=\"#题目描述：\" class=\"headerlink\" title=\"题目描述：\"></a>题目描述：</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 </p>\n<h3 id=\"输入描述\"><a href=\"#输入描述\" class=\"headerlink\" title=\"输入描述:\"></a>输入描述:</h3><p>array： 待查找的二维数组<br>target：查找的数字<br>","more":"</p>\n<h3 id=\"输出描述\"><a href=\"#输出描述\" class=\"headerlink\" title=\"输出描述:\"></a>输出描述:</h3><p>查找到返回true，查找不到返回false</p>\n<hr>\n<h3 id=\"第一次写的代码\"><a href=\"#第一次写的代码\" class=\"headerlink\" title=\"第一次写的代码\"></a>第一次写的代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> [][] array,<span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;array.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=array[i].length-<span class=\"number\">1</span>;j&gt;=<span class=\"number\">0</span>&amp;&amp;array[i][j]&gt;=target;j--)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(array[i][j]==target)<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路分析：\"><a href=\"#思路分析：\" class=\"headerlink\" title=\"思路分析：\"></a>思路分析：</h2><p>因为是二维数组，而且是每一行从左到有递增的，所以可以先从大的找起，即每行的最右边，所以逐行遍历下来，比较最右边的元素，比查找的target大则说明在那一行里面，再往回遍历那一行，遍历到就返回true，否则遍历完后没遍历到就返回false。<br>由于用了两个循环，所以。。。<br>在线编译后结果是：运行时间： 183 ms 占用内存：5075K<br>虽然AC了，但是时空非常不可观，于是，优化下看看。</p>\n<hr>\n<h3 id=\"第二次写的代码\"><a href=\"#第二次写的代码\" class=\"headerlink\" title=\"第二次写的代码\"></a>第二次写的代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> [][] array,<span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(array.length==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> divBig=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=array.length-<span class=\"number\">1</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(array[i].length&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(array[i][array[i].length-<span class=\"number\">1</span>]&gt;=target)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=array[i].length-<span class=\"number\">1</span>;j&gt;=divBig;j--)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(array[i][j]==target)<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(array[i][j]&lt;target)divBig=j;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;   </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路分析：-1\"><a href=\"#思路分析：-1\" class=\"headerlink\" title=\"思路分析：\"></a>思路分析：</h2><p>这次换了一种方式，先从右下角找起，也是逐行遍历，不过这次利用了题目说的这句话<strong>每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</strong> 优化了一下行遍历，因为列也是递增的，如果往回搜索找到列上元素比目标元素还小时，就说明在当前列的上面所有行对应的列对应的元素肯定比目标元素小，以后就不用继续遍历那些行对应的前面的列了，这样优化一下，果然时间快了一点点，不过也就一点点啊。<br>因为还是用了两个循环，时间为O（n^2）量级。<br>编译结果：运行时间： 126 ms 占用内存：5019K</p>\n<hr>\n<h3 id=\"第三次写的代码：\"><a href=\"#第三次写的代码：\" class=\"headerlink\" title=\"第三次写的代码：\"></a>第三次写的代码：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> [][] array,<span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> col=<span class=\"number\">0</span>;<span class=\"comment\">//列</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> row=array.length-<span class=\"number\">1</span>;<span class=\"comment\">//行</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(row&gt;=<span class=\"number\">0</span>&amp;&amp;col&lt;array[row].length)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(array[row][col]&gt;target)row--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(array[row][col]==target)<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> col++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这次沿用了上面的思想，但是从左下角找起，换用了一层循环，速度。。。<br>貌似快了1ms。。而已。<br>编译结果：运行时间： 125 ms 占用内存：5145K</p>"},{"title":"IP地址的分类","date":"2016-03-24T16:00:00.000Z","author":"KevinWu","_content":"根据不同特征的IP地址，对网络号所占的位数和主机号所占的位数进行分类，分为A、B、C、D、E五类地址。\n\n# A类地址\nA类地址的范围是1.0.0.0~126.255.255.255，高位以0开头，全球共有2^7-2个A类网络，每个A类网络有2^24-2个主机地址。127开头的地址保留为本地回环地址。\n<!--more-->\n# B类地址\nB类地址的范围是128.0.0.0~191.255.255.255，高位以10开头，全球共有2^14个B类网络，每个B类网络共有2^16-2个主机地址。\n\n# C类地址\nC类地址的范围是192.0.0.0~223.255.255.255，高位以110开头，全球共有2^21个C类网络，每个C类网络共有2^8-2个主机地址。\n\n# D类地址\nD类地址的范围是224.0.0.0~239.255.255.255，高位以1110开头。\n\n# E类地址\nE类地址的高位以11110开头，作为保留今后使用的地址。\n\n# 补充\n\n## 特殊的IP地址\n### 网络地址\n主机号全0的地址\n### 广播地址\n主机号全1的地址，表示特定网络的广播\n### 本地链路广播地址\n255.255.255.2.。表示本机所在的网络广播\n### 内网地址\n保留给任何一个公司单位内部网络使用的IP地址，不能出现在公网上，范围是：\n\n- 10.0.0.0~10.255.255.255\n- 172.16.0.0~172.31.255.255\n- 192.168.0.0~192.168.255.255\n\n### 链路本地地址\n无IP地址分配是由操作系统临时分配的IP地址，范围为：169.254.0.0~169.254.255.255","source":"_posts/计算机基础/201603/IP地址的分类.md","raw":"title: IP地址的分类\ndate: 2016-03-25\nauthor:  KevinWu\ncategories: 计算机基础\ntags: \n\t- 基础知识\n\t- 计算机网络\n\t- 总结\n---\n根据不同特征的IP地址，对网络号所占的位数和主机号所占的位数进行分类，分为A、B、C、D、E五类地址。\n\n# A类地址\nA类地址的范围是1.0.0.0~126.255.255.255，高位以0开头，全球共有2^7-2个A类网络，每个A类网络有2^24-2个主机地址。127开头的地址保留为本地回环地址。\n<!--more-->\n# B类地址\nB类地址的范围是128.0.0.0~191.255.255.255，高位以10开头，全球共有2^14个B类网络，每个B类网络共有2^16-2个主机地址。\n\n# C类地址\nC类地址的范围是192.0.0.0~223.255.255.255，高位以110开头，全球共有2^21个C类网络，每个C类网络共有2^8-2个主机地址。\n\n# D类地址\nD类地址的范围是224.0.0.0~239.255.255.255，高位以1110开头。\n\n# E类地址\nE类地址的高位以11110开头，作为保留今后使用的地址。\n\n# 补充\n\n## 特殊的IP地址\n### 网络地址\n主机号全0的地址\n### 广播地址\n主机号全1的地址，表示特定网络的广播\n### 本地链路广播地址\n255.255.255.2.。表示本机所在的网络广播\n### 内网地址\n保留给任何一个公司单位内部网络使用的IP地址，不能出现在公网上，范围是：\n\n- 10.0.0.0~10.255.255.255\n- 172.16.0.0~172.31.255.255\n- 192.168.0.0~192.168.255.255\n\n### 链路本地地址\n无IP地址分配是由操作系统临时分配的IP地址，范围为：169.254.0.0~169.254.255.255","slug":"计算机基础/201603/IP地址的分类","published":1,"updated":"2016-03-26T12:05:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinisi4l8001f3ntfka7zbjfv","content":"<p>根据不同特征的IP地址，对网络号所占的位数和主机号所占的位数进行分类，分为A、B、C、D、E五类地址。</p>\n<h1 id=\"A类地址\"><a href=\"#A类地址\" class=\"headerlink\" title=\"A类地址\"></a>A类地址</h1><p>A类地址的范围是1.0.0.0~126.255.255.255，高位以0开头，全球共有2^7-2个A类网络，每个A类网络有2^24-2个主机地址。127开头的地址保留为本地回环地址。<br><a id=\"more\"></a></p>\n<h1 id=\"B类地址\"><a href=\"#B类地址\" class=\"headerlink\" title=\"B类地址\"></a>B类地址</h1><p>B类地址的范围是128.0.0.0~191.255.255.255，高位以10开头，全球共有2^14个B类网络，每个B类网络共有2^16-2个主机地址。</p>\n<h1 id=\"C类地址\"><a href=\"#C类地址\" class=\"headerlink\" title=\"C类地址\"></a>C类地址</h1><p>C类地址的范围是192.0.0.0~223.255.255.255，高位以110开头，全球共有2^21个C类网络，每个C类网络共有2^8-2个主机地址。</p>\n<h1 id=\"D类地址\"><a href=\"#D类地址\" class=\"headerlink\" title=\"D类地址\"></a>D类地址</h1><p>D类地址的范围是224.0.0.0~239.255.255.255，高位以1110开头。</p>\n<h1 id=\"E类地址\"><a href=\"#E类地址\" class=\"headerlink\" title=\"E类地址\"></a>E类地址</h1><p>E类地址的高位以11110开头，作为保留今后使用的地址。</p>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><h2 id=\"特殊的IP地址\"><a href=\"#特殊的IP地址\" class=\"headerlink\" title=\"特殊的IP地址\"></a>特殊的IP地址</h2><h3 id=\"网络地址\"><a href=\"#网络地址\" class=\"headerlink\" title=\"网络地址\"></a>网络地址</h3><p>主机号全0的地址</p>\n<h3 id=\"广播地址\"><a href=\"#广播地址\" class=\"headerlink\" title=\"广播地址\"></a>广播地址</h3><p>主机号全1的地址，表示特定网络的广播</p>\n<h3 id=\"本地链路广播地址\"><a href=\"#本地链路广播地址\" class=\"headerlink\" title=\"本地链路广播地址\"></a>本地链路广播地址</h3><p>255.255.255.2.。表示本机所在的网络广播</p>\n<h3 id=\"内网地址\"><a href=\"#内网地址\" class=\"headerlink\" title=\"内网地址\"></a>内网地址</h3><p>保留给任何一个公司单位内部网络使用的IP地址，不能出现在公网上，范围是：</p>\n<ul>\n<li>10.0.0.0~10.255.255.255</li>\n<li>172.16.0.0~172.31.255.255</li>\n<li>192.168.0.0~192.168.255.255</li>\n</ul>\n<h3 id=\"链路本地地址\"><a href=\"#链路本地地址\" class=\"headerlink\" title=\"链路本地地址\"></a>链路本地地址</h3><p>无IP地址分配是由操作系统临时分配的IP地址，范围为：169.254.0.0~169.254.255.255</p>\n","excerpt":"<p>根据不同特征的IP地址，对网络号所占的位数和主机号所占的位数进行分类，分为A、B、C、D、E五类地址。</p>\n<h1 id=\"A类地址\"><a href=\"#A类地址\" class=\"headerlink\" title=\"A类地址\"></a>A类地址</h1><p>A类地址的范围是1.0.0.0~126.255.255.255，高位以0开头，全球共有2^7-2个A类网络，每个A类网络有2^24-2个主机地址。127开头的地址保留为本地回环地址。<br>","more":"</p>\n<h1 id=\"B类地址\"><a href=\"#B类地址\" class=\"headerlink\" title=\"B类地址\"></a>B类地址</h1><p>B类地址的范围是128.0.0.0~191.255.255.255，高位以10开头，全球共有2^14个B类网络，每个B类网络共有2^16-2个主机地址。</p>\n<h1 id=\"C类地址\"><a href=\"#C类地址\" class=\"headerlink\" title=\"C类地址\"></a>C类地址</h1><p>C类地址的范围是192.0.0.0~223.255.255.255，高位以110开头，全球共有2^21个C类网络，每个C类网络共有2^8-2个主机地址。</p>\n<h1 id=\"D类地址\"><a href=\"#D类地址\" class=\"headerlink\" title=\"D类地址\"></a>D类地址</h1><p>D类地址的范围是224.0.0.0~239.255.255.255，高位以1110开头。</p>\n<h1 id=\"E类地址\"><a href=\"#E类地址\" class=\"headerlink\" title=\"E类地址\"></a>E类地址</h1><p>E类地址的高位以11110开头，作为保留今后使用的地址。</p>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><h2 id=\"特殊的IP地址\"><a href=\"#特殊的IP地址\" class=\"headerlink\" title=\"特殊的IP地址\"></a>特殊的IP地址</h2><h3 id=\"网络地址\"><a href=\"#网络地址\" class=\"headerlink\" title=\"网络地址\"></a>网络地址</h3><p>主机号全0的地址</p>\n<h3 id=\"广播地址\"><a href=\"#广播地址\" class=\"headerlink\" title=\"广播地址\"></a>广播地址</h3><p>主机号全1的地址，表示特定网络的广播</p>\n<h3 id=\"本地链路广播地址\"><a href=\"#本地链路广播地址\" class=\"headerlink\" title=\"本地链路广播地址\"></a>本地链路广播地址</h3><p>255.255.255.2.。表示本机所在的网络广播</p>\n<h3 id=\"内网地址\"><a href=\"#内网地址\" class=\"headerlink\" title=\"内网地址\"></a>内网地址</h3><p>保留给任何一个公司单位内部网络使用的IP地址，不能出现在公网上，范围是：</p>\n<ul>\n<li>10.0.0.0~10.255.255.255</li>\n<li>172.16.0.0~172.31.255.255</li>\n<li>192.168.0.0~192.168.255.255</li>\n</ul>\n<h3 id=\"链路本地地址\"><a href=\"#链路本地地址\" class=\"headerlink\" title=\"链路本地地址\"></a>链路本地地址</h3><p>无IP地址分配是由操作系统临时分配的IP地址，范围为：169.254.0.0~169.254.255.255</p>"},{"title":"单工、半双工和全双工微总结","date":"2016-03-24T16:00:00.000Z","author":"KevinWu","_content":"简单总结下这三个名词。\n现在有A和B。\n# 单工\nA能发送消息给B，B只能接受A的消息，B不能给A发消息。\n\n# 半双工\nA能发送消息给B，B也能发送消息给A，但不能同时进行，当A在发送消息时，B只能接受，反之一样。\n\n# 全双工\nA能发送消息给B，B也能发送消息给A，两者能同时进行。\n","source":"_posts/计算机基础/201603/单工、半双工和全双工微总结.md","raw":"title: 单工、半双工和全双工微总结\ndate: 2016-03-25\nauthor:  KevinWu\ncategories: 计算机基础\ntags: \n\t- 基础知识\n\t- 计算机网络\n\t- 总结\n---\n简单总结下这三个名词。\n现在有A和B。\n# 单工\nA能发送消息给B，B只能接受A的消息，B不能给A发消息。\n\n# 半双工\nA能发送消息给B，B也能发送消息给A，但不能同时进行，当A在发送消息时，B只能接受，反之一样。\n\n# 全双工\nA能发送消息给B，B也能发送消息给A，两者能同时进行。\n","slug":"计算机基础/201603/单工、半双工和全双工微总结","published":1,"updated":"2016-03-26T12:05:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinisi4le001o3ntfgsflwe4i","content":"<p>简单总结下这三个名词。<br>现在有A和B。</p>\n<h1 id=\"单工\"><a href=\"#单工\" class=\"headerlink\" title=\"单工\"></a>单工</h1><p>A能发送消息给B，B只能接受A的消息，B不能给A发消息。</p>\n<h1 id=\"半双工\"><a href=\"#半双工\" class=\"headerlink\" title=\"半双工\"></a>半双工</h1><p>A能发送消息给B，B也能发送消息给A，但不能同时进行，当A在发送消息时，B只能接受，反之一样。</p>\n<h1 id=\"全双工\"><a href=\"#全双工\" class=\"headerlink\" title=\"全双工\"></a>全双工</h1><p>A能发送消息给B，B也能发送消息给A，两者能同时进行。</p>\n","excerpt":"","more":"<p>简单总结下这三个名词。<br>现在有A和B。</p>\n<h1 id=\"单工\"><a href=\"#单工\" class=\"headerlink\" title=\"单工\"></a>单工</h1><p>A能发送消息给B，B只能接受A的消息，B不能给A发消息。</p>\n<h1 id=\"半双工\"><a href=\"#半双工\" class=\"headerlink\" title=\"半双工\"></a>半双工</h1><p>A能发送消息给B，B也能发送消息给A，但不能同时进行，当A在发送消息时，B只能接受，反之一样。</p>\n<h1 id=\"全双工\"><a href=\"#全双工\" class=\"headerlink\" title=\"全双工\"></a>全双工</h1><p>A能发送消息给B，B也能发送消息给A，两者能同时进行。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cinisi4k400043ntfo5yt6v0x","category_id":"cinisi4kb00063ntfmqi5sti6","_id":"cinisi4kc00083ntfv8lm0xsj"},{"post_id":"cinisi4kf000h3ntfhlk7eyoh","category_id":"cinisi4kb00063ntfmqi5sti6","_id":"cinisi4kl000j3ntfs6ynh68y"},{"post_id":"cinisi4kp000q3ntfs4dk6c84","category_id":"cinisi4kb00063ntfmqi5sti6","_id":"cinisi4kr000s3ntff5qbtn4b"},{"post_id":"cinisi4ks000v3ntfm2ye5yvf","category_id":"cinisi4kv000x3ntfnvxsfuzy","_id":"cinisi4kw000z3ntfx7ilp82q"},{"post_id":"cinisi4kx00133ntf6y8x1y05","category_id":"cinisi4kv000x3ntfnvxsfuzy","_id":"cinisi4kz00153ntfx1bmd21x"},{"post_id":"cinisi4l200183ntfggk276ai","category_id":"cinisi4l4001a3ntfculkzjqp","_id":"cinisi4l5001c3ntfbrtks124"},{"post_id":"cinisi4l8001f3ntfka7zbjfv","category_id":"cinisi4l9001h3ntf6kok7w3a","_id":"cinisi4la001j3ntfg1x2963o"},{"post_id":"cinisi4le001o3ntfgsflwe4i","category_id":"cinisi4l9001h3ntf6kok7w3a","_id":"cinisi4lg001r3ntf1jv9mrqy"}],"PostTag":[{"post_id":"cinisi4k400043ntfo5yt6v0x","tag_id":"cinisi4k900053ntfml2jgrdw","_id":"cinisi4ke000c3ntfj0fc2blu"},{"post_id":"cinisi4k400043ntfo5yt6v0x","tag_id":"cinisi4kc00073ntfd0zg53bx","_id":"cinisi4ke000d3ntfgg2dm4ph"},{"post_id":"cinisi4k400043ntfo5yt6v0x","tag_id":"cinisi4kc00093ntf1z4f647a","_id":"cinisi4ke000e3ntf6ope3xgp"},{"post_id":"cinisi4k400043ntfo5yt6v0x","tag_id":"cinisi4kd000a3ntficoskbff","_id":"cinisi4ke000f3ntfjqvp7a9d"},{"post_id":"cinisi4k400043ntfo5yt6v0x","tag_id":"cinisi4kd000b3ntfqe9scozj","_id":"cinisi4ke000g3ntffdbgy6a8"},{"post_id":"cinisi4kf000h3ntfhlk7eyoh","tag_id":"cinisi4k900053ntfml2jgrdw","_id":"cinisi4ko000m3ntfa1ttv04b"},{"post_id":"cinisi4kf000h3ntfhlk7eyoh","tag_id":"cinisi4ki000i3ntff58a1f91","_id":"cinisi4ko000n3ntfb5bd47lp"},{"post_id":"cinisi4kf000h3ntfhlk7eyoh","tag_id":"cinisi4kl000k3ntf53a7s8sx","_id":"cinisi4ko000o3ntf9rfwjvmk"},{"post_id":"cinisi4kf000h3ntfhlk7eyoh","tag_id":"cinisi4kn000l3ntfvmfk3pt5","_id":"cinisi4ko000p3ntffzks3gth"},{"post_id":"cinisi4kp000q3ntfs4dk6c84","tag_id":"cinisi4k900053ntfml2jgrdw","_id":"cinisi4kr000t3ntf4chsxo8v"},{"post_id":"cinisi4kp000q3ntfs4dk6c84","tag_id":"cinisi4kq000r3ntfss6hzuur","_id":"cinisi4kr000u3ntfbpjxq0zp"},{"post_id":"cinisi4ks000v3ntfm2ye5yvf","tag_id":"cinisi4k900053ntfml2jgrdw","_id":"cinisi4kw00103ntffx9zcnyg"},{"post_id":"cinisi4ks000v3ntfm2ye5yvf","tag_id":"cinisi4kv000w3ntfr7f16q9m","_id":"cinisi4kw00113ntfvmghqz68"},{"post_id":"cinisi4ks000v3ntfm2ye5yvf","tag_id":"cinisi4kw000y3ntfhhnmpuqw","_id":"cinisi4kx00123ntf354fld3k"},{"post_id":"cinisi4kx00133ntf6y8x1y05","tag_id":"cinisi4k900053ntfml2jgrdw","_id":"cinisi4l000163ntfo87kcz3n"},{"post_id":"cinisi4kx00133ntf6y8x1y05","tag_id":"cinisi4kz00143ntf1lyzhbfb","_id":"cinisi4l000173ntfs4en6h9n"},{"post_id":"cinisi4l200183ntfggk276ai","tag_id":"cinisi4l400193ntfadjcgp0j","_id":"cinisi4l6001d3ntfk7pogiv1"},{"post_id":"cinisi4l200183ntfggk276ai","tag_id":"cinisi4l5001b3ntft2wqwhjz","_id":"cinisi4l7001e3ntffuewn8zv"},{"post_id":"cinisi4l8001f3ntfka7zbjfv","tag_id":"cinisi4l9001g3ntft7f52un9","_id":"cinisi4lb001l3ntfhhkmn9nz"},{"post_id":"cinisi4l8001f3ntfka7zbjfv","tag_id":"cinisi4la001i3ntf59udq31c","_id":"cinisi4lb001m3ntf4j6tc5it"},{"post_id":"cinisi4l8001f3ntfka7zbjfv","tag_id":"cinisi4la001k3ntfnizqlh8s","_id":"cinisi4lb001n3ntfhfan4x9v"},{"post_id":"cinisi4le001o3ntfgsflwe4i","tag_id":"cinisi4l9001g3ntft7f52un9","_id":"cinisi4lg001p3ntfna6lcnd5"},{"post_id":"cinisi4le001o3ntfgsflwe4i","tag_id":"cinisi4la001i3ntf59udq31c","_id":"cinisi4lg001q3ntfpkdei35s"},{"post_id":"cinisi4le001o3ntfgsflwe4i","tag_id":"cinisi4la001k3ntfnizqlh8s","_id":"cinisi4lg001s3ntfjuv7e3wd"}],"Tag":[{"name":"Java","_id":"cinisi4k900053ntfml2jgrdw"},{"name":"Android","_id":"cinisi4kc00073ntfd0zg53bx"},{"name":"Gson","_id":"cinisi4kc00093ntf1z4f647a"},{"name":"Json","_id":"cinisi4kd000a3ntficoskbff"},{"name":"解析","_id":"cinisi4kd000b3ntfqe9scozj"},{"name":"Android - 加载模式","_id":"cinisi4ki000i3ntff58a1f91"},{"name":"Activity","_id":"cinisi4kl000k3ntf53a7s8sx"},{"name":"启动模式","_id":"cinisi4kn000l3ntfvmfk3pt5"},{"name":"RxJava","_id":"cinisi4kq000r3ntfss6hzuur"},{"name":"JVM","_id":"cinisi4kv000w3ntfr7f16q9m"},{"name":"虚拟机","_id":"cinisi4kw000y3ntfhhnmpuqw"},{"name":"集合","_id":"cinisi4kz00143ntf1lyzhbfb"},{"name":"查找","_id":"cinisi4l400193ntfadjcgp0j"},{"name":"二维数组","_id":"cinisi4l5001b3ntft2wqwhjz"},{"name":"基础知识","_id":"cinisi4l9001g3ntft7f52un9"},{"name":"计算机网络","_id":"cinisi4la001i3ntf59udq31c"},{"name":"总结","_id":"cinisi4la001k3ntfnizqlh8s"}]}}